\documentclass[a4paper,style=print,oneside,bibliography=totoc,nexus,lnum,extramargin]{tubsbook}

\input{header.tex}
\usepackage[english]{babel}

\hypersetup{
    colorlinks, linkcolor={medium-blue},
    citecolor={medium-blue}, urlcolor={medium-blue}
}

%\titlehead{
%    \begin{center}
%        \includegraphics[width=0.5\textwidth]{square_example.png}
%    \end{center}
%}

\subject{Master's Thesis}
\title{Split Packing:\\ A Worst-Case Optimal Circle Packing Algorithm}
\author{\sffamily\LARGE Sebastian Morr}
\date{\large June 2, 2016}
\publishers{\textbf{Institute of Operating Systems and Computer Networks\\Prof.\,Dr.\,Sándor\,Fekete}\\
\vspace*{2em}
Supervisors:\\
Dr.\,Christian\,Scheffer\\
Jan-Marc\,Reinhardt,\,M.\,Sc.}

\begin{document}

\frontmatter % roman page numbering

\maketitle
\cleardoublepage

% statement of originality
\thispagestyle{plain} % no header
\vspace*{7cm}
\centerline{\bfseries Statement of Originality}
\vspace*{1em}
\noindent
This thesis has been performed independently with the support of my supervisors.
To the best of my knowledge, this thesis contains no material previously
published or written by another person except where due reference is made in the text.

\par
  \bigskip\noindent Braunschweig, June 2, 2016 \par
  \vspace*{10mm}
  \hfill\hrulefill
\cleardoublepage

% abstract
\thispagestyle{plain} % no header
\centerline{\bfseries Abstract}
\vspace*{1em}
\noindent
In this thesis, we describe an algorithm for packing circles and other objects into various containers.

Not only do we prove these upper bounds for many container types for the first time, but we do it by giving a constructive algorithm that realizes these packings.

We show that Split Packing is able to pack circles with worst-case density into the following container shapes:

Any right or obtuse triangles,
equilateral triangles, and isosceles triangles whose longest side is the base,
squares,
rectangles with an aspect ratio of more than 1:1.57

As another generalization, we show that Split Packing can be used to pack octagons worst-case optimally into squares. If we allow to rotate objects, we can also pack squares worst-case optimally.

We have only begun to study the properties of Split Packing in this thesis and see many open research questions.

\cleardoublepage

\section*{Acknowledgments}

I would like to thank the following people for their support in the creation of this thesis:

Christiane, your lecture in 2014 started it all.

Michael, for your support back then. We all miss you.

Christian, for always taking the time for me and for sharing my enthusiasm.

Jan-Marc, you were the first one I showed the Split Packing algorithm.

Sándor, for suggesting the aweseome topic to me.

All participants of the 31th Bellairs Winter Workshop on Computational Geometry. I drew much inspiration from every one of you!

Heike, for being my best friend, and for softing my life.

Wolfgang, for your love and unconditional support in uncountable ways.

Dominik, for sharing an office and ideas (and for the Mate supply!)

Marco, for spending late hours with me pondering over covering problems.

The Pinky Crew: Leslie, Moritz, Torsten, Jakob, Marc, for sharing breakfast, time, and friendship.

The proof-readers, that is, YOU, PROOF-READING THIS RIGHT NOW, thx! <3

Enrico, for creating the beautiful \LaTeX\ template.

\section*{Colophon}

This document was created using \LaTeXe\ by Leslie Lamport and contributors, and \KOMAScript\ by Frank Neukam, Markus Kohm, and Axel Kielhorn. The figures were created using PGFPlots by Christian Feuersänger and Ti\textit{k}Z by Till Tantau. The text is set in the Latin Modern font family by Bogusław Jackowski, Janusz M. Nowacki and Marcin Woliński, the monospaced font is \texttt{Bera Mono}, based on Bitstream Vera.

\cleardoublepage
\setcounter{tocdepth}{1}

\tableofcontents
\cleardoublepage

\mainmatter % arabic numbering

\chapter{Introduction}

Suppose you are given a number of circles. Can you decide whether these circles can be packed into the unit square without overlapping each other or the square? This is known as the circle packing problem, and it is known to be NP-hard \cite{DFL2010circle}, which means there is (assuming $P \ne NP$) no deterministic polynomial-time algorithm which can decide that.

\fig[2.5]{big-question}{Can these circles be packed into the square?}

%For hard decision problems, it is often interesting to look for necessary and sufficient conditions.
Surely, there are necessary conditions for a packing to exist. For example, if the circles' combined area exceeds the area of the square, we can be certain that they can \emph{not} be packed.
On the other hand, an upper bound on the circles' combined area could also serve as a sufficient condition. We might be able to say: If the circles' combined area does not exceed some number $a$, then they can always be packed.

In fact, we could not only ask for \emph{some} $a$, but for the largest one. This is the problem which motivated this thesis:

\begin{problem}\label{prb:1}
    What is the largest $a$ so that all sets of circles with a combined area of $a$ can be packed into the unit square?
\end{problem}

Already in 1967, \textcite{MM1967some} solved this problem for square objects. They proved that it is possible to pack a set of squares into the unit square, if their combined area does not exceed $1/2$. Their method first sorts the squares descending by size and then places them in the container square in a shelf-like manner. See \Cref{fig:shelf-packing} for an example packing. But at the same time, $1/2$ is the \emph{largest upper bound} you could hope for. Consider the square packing in \Cref{fig:worst-cases}, consisting of two quarter-squares: If you made the squares only slightly larger, they could no longer be packed without overlapping each other.

%Already in 1967, \textcite{MM1967some} gave such a sufficient condition for packing square objects: They proved that it is possible to pack a set of squares into the unit square, if their combined area does not exceed $1/2$. Their method first sorts the squares descending by size and then places them in the container square in a shelf-like manner. See \Cref{fig:shelf} for an example packing. 

\fig[7]{shelf-packing}{Example of Moon and Moser's shelf-packing.}

The equivalent problem for packing circles has since been open.
When \textcite{DFL2010circle} posed \Cref{prb:1} in 2010, they already suggested that the largest packable area might be limited by the circle instance shown in \Cref{fig:worst-cases}. Again, it is easy to argue that if these two circles were only a little larger, we could no longer pack them into the unit square without overlap. This means that their combined area represents an upper bound on the area which can always be packed.

\fig[5]{worst-cases}{Left: Worst case for packing squares into a square. Right: Conjectured worst case for packing circles into a square.}

In this thesis, we will give a constructive proof that you can indeed pack all circle instances whose area does not exceed the combined area of the two circles shown in \Cref{fig:worst-cases} into the unit square.
The method is based on a divide-and-conquer approach and repeatedly splits the circle instance in halves, which are then packed recursively.
%recursively splits the circle instance in half and packs the two parts seperately.
See \Cref{fig:example} for an example packing.
We will also generalize this packing approach to certain classes of triangles and rectangles, and demonstrate that it also can be used to pack other objects than circles.

\fig[0.02]{example}{Example packing produced by the Split Packing algorithm.}

%It is easy to argue that these two circles cannot be packed into any smaller square, which means that the unit square is their \emph{optimal packing}
%proposed a candidate for such a worst-case instance in terms of optimal packing denstiy: Two equally sized circles. Their optimal packing is depicted in \Cref{square-worst}.%, and has a packing density of ~0.53\%.

%How can we find $a^*$? It seems worthwhile to look for circle instances whose optimal packing is exactly the unit square.

%The circles' combined area then serves as an upper bound for $a$. When increasing the circles' areas only by $\varepsilon$, they can no longer be packed.

%Many instances with this property will have a much smaller \emph{optimal} packing, meaning that they can also be packed into a square smaller than the square.
%But in order to find the largest factor $a$, it might help to .

%at circle instances with an exceptionally bad 

%In packing problems, one often calls the ratio between the objects' combined area and the area of the container the \emph{packing density}.
%This largest $a$, then represents something which we call the \emph{cricital packing density} for packing circles into a square: All circle instances with at most this packing density can be packed, and for all larger packing densities, one can find a circle instance which cannot be packed.

%To find this critical density, it might help to look at circle instances with an exceptionally bad \emph{optimal} packing density. We know that there needs to be at least one circle instance whose optimal packing density is exactly $a$: If all circle instances had a better optimal packing density, we could raise $a$...

%How to find this critical density? For 



%The equivalent problem for packing circles has since been open.
%When \textcite{DFL2010circle} posed \Cref{prb:1} in 2010, they already made 

%proposed a candidate for such a worst-case instance in terms of optimal packing denstiy: Two equally sized circles. Their optimal packing is depicted in \Cref{square-worst}.%, and has a packing density of ~0.53\%.



%When friends and family ask what this thesis is about
%ask about what I am working on, more often than not, it seems hard to answer without going deep into the basics of computer science. This thesis, on the other hand, deals with a problem that is so intuitive that even a 10-second summary covers it pretty well:
%


%In this thesis, we ask the same question for packing circles into various containers.

%Our original motivation comes from an unexpected direction: Origami design.

%Consider the circle packing shown in \Cref{fig:worst-case}. It is easy to argue that these two circles cannot be packed into any smaller square. Call their combined area $a$. We considered the following problem: Can all circle instances with a combined area of $a$ (like the one in \Cref{fig:big-question}) be packed into this specific square?
%If so, the packing density in \Cref{fig:worst-case} would be the \emph{critical density} for packing circles in a square: All circle instances with a lower packing density could be packed in the square, and for all higher densities one could find circle instances which could not be packed. In other words, the two above circles would represent a worst-case instance in terms of packing density. In this thesis, we give a constructive proof that this is indeed the case.

\section{Results}

In \Cref{tab:results} and \Cref{tab:results2}, we summarize our results. Each entry shows a combination of container shape and object shape which can be packed worst-case optimally. Additionally, eachh entry includes a graphical depiction of the instance which limits the maximally packable area, and a formula for the packing density of this worst case.

\begin{table}
    \caption{Overview of results for packing circles.}\label{tab:results}
    \begin{longtable}{cp{10cm}}
        \entry{1.9}{tri-table}{Circles in a right/obtuse triangle}
        {$a^2+b^2 \le c^2$}%
        %{incircle area}
        {$\sqrt{\dfrac{-(a-b-c)(a+b-c)(a-b+c)}{(a+b+c)^3}}\pi < 53.91\%$}

        \entry{2.4}{iso-table}{Circles in a thick isosceles triangle}
        {$a/\s \le b \le a$}%
        %{“twincircle” area}
        {$48.60\% < \dfrac{(a-2b+\sqrt{4b^2-a^2})^2\pi}{2a\sqrt{4b^2-a^2}} < 53.91\%$}

        \entry{2.8}{square-table}{Circles in a square}
        {--}%
        %{“twincircle” area}
        {$\dfrac{\pi}{3+2\s} \approx 53.90\%$}

        \entry{3}{rect-table}{Circles in a long rectangle}
        {$w = \frac{2+3\s}{4}h \approx 1.5607h$}%
        %{circle with diameter $h$}
        {$\dfrac{\pi h}{4w} < 50.33\%$}
    \end{longtable}
\end{table}

\begin{table}
    \caption{Overview of results for packing other objects.}\label{tab:results2}
    \begin{longtable}{cp{10cm}}
        \entry{2.5}{squares-in-square-table}{Squares in a square}
        {}
        {$50\%$}

        \entry{2.5}{octagons-in-square-table}{Octagons in a square}
        {}
        {$8(5\s-7) \approx 56.85\%$}

        \entry{2.5}{rubies-in-square-table}{“Rubies” in a square}
        {}
        {$8\sqrt{2(\s-1)}+6\s-15 \approx 76.67\%$}

        \entry{1.8}{squares-in-tri-table}{Squares in an isosceles right triangle}
        {}
        {$50\%$}

        \entry{1.8}{octagons-in-tri-table}{Octagons in an isosceles right triangle}
        {}
        {$8(5\s-7) \approx 56.85\%$}

        \entry{1.8}{rubies-in-tri-table}{“Sharp rubies” in an isosceles right triangle}
        {}
        {$4\sqrt{2(\s-1)} + 3\s -7 \approx 88.34\%$}
    \end{longtable}
\end{table}

When using Split Packing as an approximation algorithm, the approximation factor $ALG/OPT$ is equal to the reciprocal of the guaranteed packing density.

Significance

%Furthermore, we describe an algorithm which is able to pack circles into non-acute triangles with worst-case density.
%
%More formally, this thesis builds up to the proofs of these main theorems:
%
%\begin{theorem}
%    Given a square of area $a$, all circle instances with a combined area of at most $\frac{\pi}{3+2\s} a$ can be packed into that square.
%\end{theorem}
%
%\begin{theorem}
%    Given a non-acute triangle with an incircle of area $a$, all circle instances with a combined area of at most $a$ can be packed into that triangle.
%\end{theorem}

\section{Applications}

Circle packing is a natural, intuitive problem, that has numerous applications in engineering, science, and everyday life.

\paragraph{Packaging}

An obvious application is packaging: Given a set of cylindrical objects (like bottles or cans), one might want to determine the minimum-volume parcel in which all objects can be packed \parencite{CKP2008solving}. Or, given a shipping container of fixed size, one might want to pack as many rolls of paper into it as possible \parencite{fraser1994integrated}.

\paragraph{Bundling}

A similar application involves cylinder bundles:
One might want to run a number of optical fibers through a tube, or place multiple pipes with different diameters inside of a larger one \parencite{WHZX2002improved}. As another example, a car manufacturer might want to drill circular holes into a car's body and route a number of sensor cables through that hole, while keeping the hole as small as possible \cite{SSSKK2004disk}.

\paragraph{Cutting industry}

Circle packing is applicable in the cutting indsutry, where one might want to cut circular pieces from a material, minimizing waste \cite{SMCSCG2007new}.
A related problem is the layout of control panels containing circular controls (like in airplane cockpits, for example), which should be placed space-efficiently \parencite{CKP2008solving}.

\paragraph{Communication}

In the context of digital modulation schemes, \emph{quadrature amplitude modulation} is using circle packings to divide the two-dimensional phase-amplitude space into regions, which encode different binary patterns. Larger circles lead to increased noise tolerances \parencite{PWMD1992packing}.
Network planners might want to place radio towers in a geographical region, mimimizing interference, but maximizing coverage \parencite{SMCSCG2007new}.

\paragraph{Chemistry}

Other applications stem from chemistry, where one can study dense packings of atoms in crystals or macromolecules \cite{WMP1994history}.

\paragraph{Foresting}

In foresting, one might want to plant trees so that the grown forest will be as dense as possible, but the trees do not hinder each other's growth \cite{SMCSCG2007new}.

\paragraph{Design}

A surprising application of circle packing involves the design of crease patterns for Origami. In this problem, one wants to determine a sequence of folds of a square piece of paper, so that the result resembles a specific shape. The design of Origami structures which resemble trees involves a packing problem called circle/river-packing. See \Cref{fig:origami} on \cpageref{fig:origami} for an example. This kind of Origami design was pioneered by Robert J. Lang \cite{lang1996computational}. Using circle packings (without “rivers”), one can design crease patterns for folding arbitrary stars.

\section{Organization}

This thesis is structured as follows:
In \textbf{\Cref{ch:related-work}}, we give an overview aobout related work regarding the packing of squares and circles.
In \textbf{\Cref{ch:split-packing}}, we describe the general Split Packing algorithm and analyze its properties.
In \textbf{\Cref{ch:circles}}, we describe how to use Split Packing for packing circles into triangles.
In \textbf{\Cref{ch:rubies}}, we show that the algorithm can be generalized to pack objects different than circles.
Finally, in \textbf{\Cref{ch:conclusions}}, we summarize our results and show some directions for future work.

\chapter{Related work}\label{ch:related-work}

The literature on packing can roughly be divided into three categories, depending on the authors' objective:

Some authors strive to obtain the \textbf{optimal solutions} to packing problems. As almost all interesting packing problems are NP-hard, this becomes incredibly computationally expensive for more than a few objects.
So, another approach is to design \textbf{heuristics} in order to obtain “good” solutions. These solutions are often close-to-optimal, but might degenerate for certain instances and thus make no guarantees about the actual quality of the produced packings.
Finally, some authors develop \textbf{approximation algorithms}, which do make performance guarantees about the obtained solutions. In the best case, these algorithms produce solutions which are only a constant factor away from the optimal ones.

A packing problem usually consists of three components: The first component is the type of objects that are to be packed. For example, these can be square or circular objects, and they can be allowed to have different sizes or be restricted to be of equal size. The second component is the type of the container, for example, a square, a triangle, a general polygon. Thirdly, one can define restrictions on the movement of the objects: The objects could be allowed to rotate, or be restricted to translations only. Throughout this thesis, we allow the objects to be translated, rotated and reflected unless mentioned otherwise. There are also online variants of packing problems, where the object instance is not known beforehand, but in this, we restrict ourselves to offline approaches.

In general, packing arbitraryly-shaped objects into arbitrary containers can immediately shown to be NP-hard: Consider a rectangular container of dimensions $2 \times n$ and rectangular objects of height $1$, whose widths add up to $n$. The decision problem whether it is possible to pack these objects into the container without rotation is a reduction from \textsc{Partition}.

\section{Packing squares}\label{sec:related-squares}

We start by briefly reviewing related work on packing squares into various containers.
Algorithms which pack squares are interesting to us in the context of this thesis as we can directly use them for packing circles: We replace each circle of radius $r$ with a square of edge length $2r$ and pack the resulting squares to receive a packing of the original circle instance. In a sense, square-packing approximation algorithms provide us with lower bounds on what more specialized circle-packing approximation algorithms should be able to accomplish.

\subsection{Hardness}

We get a seemingly simple packing problem by restricting the container as well as the objects to be (not necessarily equal) squares.
Even tough, decision problem whether it is possible to pack a given set of squares into a square container was shown to be strongly NP-complete by \textcite{LTWYC1990packing} through a reduction from \textsc{3-Partition}.

For another variant, we could restrict the square objects to be equally sized, but allow the container to be arbitrary.
In this case, too, the decision problem remains hard:
\textcite{FPT1981optimal} showed it to be NP-hard to pack equal squares into arbitrary polygons with holes by a reduction from \textsc{3-SAT}. They construct gadgets for variables and clauses and connect them with wires.

\subsection{Approximation algorithms}

As mentioned in the introduction of this chapter, we can directly use approximation algorithms for packing squares to obtain approximation algorithms for packing circles.
If we are given an algorithm which can pack all square instances with a combined area of $a$ into a given shape, we immediately get an algorithm which can pack all circle instances with a combined area of $\frac{\pi}{4}a \approx 0.7854a$ into that shape. 

As already mentioned in the introduction, \textcite{MM1967some} developed an algorithm which can pack all square instances with a combined area of $1/2$ into the unit square.
They sort the squares by their size and place them into the square in a shelf-like manner, see \Cref{fig:shelf-packing} on \cpageref{fig:shelf-packing}.
They also proofed that $1/2$ is the critical density when packing squares into a square: Two squares, each with an area of more than $1/4$ of the container's area, cannot be packed.
As by above remark, this algorithm can be used to pack circles: It can pack all circle instances with a combined area of $\pi/8 \approx 0.3927$ into the unit square.

\textcite{KK1975optimal} showed that any square instance with a combined area of~1 can be packed into a rectangle of dimensions $2/\sqrt{3} \times \sqrt{2} \approx 1.1547 \times 1.4142$, and that this is the smallest-area rectangle with that property. The packing density in this case is approximately $0.6124$. Applied to circles, this result means that all circle instances with a combined area of~1 can be packed into a rectangle of dimensions $4/\sqrt{3\pi} \times 2\sqrt{2}/\sqrt{\pi} \approx 1.3030 \times 1.5958$, with a packing density of approximately $0.4810$.

\textcite{hougardy2011packing} recently showed that for any set of squares with a combined area of~1, there is some rectangle with an area of less than $1.4$ in which the squares can be packed using a computer generated proof. This means that for any set of circles with a combined area of~1, there is some rectangle with an area of less than $28\pi/5 \approx 1.7825$ in which the circles can be packed.

\section{Packing circles}

There is a large body of work regarding the packing of circles into various containers. Most authors have considered the packing of equal circles into squares, see \textcite{SMCSCG2007new} for an overview of numerous heuristics and optimization methods. \textcite{HM2009literature} survey the literature on packing unequal circles into squares, rectangles, circles and other shapes, as well as on packing spheres into three-dimensional containers.

%Most authors try to get as close to the optimal packings of given instances as possible. Optimal solutions are only known for small instances, so that the majority of authors either focus on heuristics or model circle packing as a global optimization problem.

\subsection{Hardness}

The decision problem whether it is possible to pack a given set of unequal circles into a given square, a rectangle, or an equilateral triangle was shown to be NP-complete by \textcite{DFL2010circle}, by a reduction from \textsc{3-Partition}: They build a circle instance which first forces some symmetrical free “pockets” in the resulting circle packing. The instance's remaining circles can then be packed into these pockets exactly if the related \textsc{3-Partition} instance has a solution.

\subsection{Density bounds}

The densest packing of equal circles in the plane can be easily guessed: Arrange them on a hexagonal grid, so that each circle touches six others. This arrangement results in a packing density of $\pi/\sqrt{12} \approx 0.9069$. An incomplete proof was given by \textcite{thue1892om}, which was later fixed by \textcite{fejestoth1940uber}. For a simple proof, see the paper of \textcite{CW2010simple}.

For unequal circles, the optimal packing density can get arbitrarily close to 1 if the circle instance is chosen so that it can be packed in the manner of an Apollonian gasket (see \Cref{fig:apollonian}), or in another asymptotically space filling manner, like in the construction of \textcite{bourke2011random}.

\fig{apollonian}{Circle instances which force a packing in the style of an Apollonian gasket approach a packing density of 1.}

\subsection{Optimal packings}

A problem which has been considered a lot is the following: What is the smallest square in which $n$ unit circles can be packed?
Surprisingly, optimal results are only known for $n < 35$.

The optimal packings of up to nine equal circles in a square were already known in 1965: The cases for $n \le 6$ are trivial,
\textcite{schaer1965densest} proved the optimal solutions for $n = 7$ and $n = 8$, and \textcite{SM1965geometric} the one for $n = 9$.

(TODO: figure of up to n=9?)

The optimal solution for $n = 10$ was confirmed only in 1990, by \textcite{DPW1990optimal}. In the same paper, they also prove the optimal solutions for 11, 12 and 13 circles.
See \textcite{WMP1994history} for an overview of the history of optimal solutions for $n \le 13$.

Some years later, \textcite{NO1998more} provided computer-aided optimality proofs for $n \le 27$. Their algorithm is based on a procedure by \textcite{PWMD1992packing}.
\textcite{MC2005new} give computer-aided proofs for $n=28,29,30$ within very tight tolerance values.
Finally, \textcite{LR2002packing} proved solutions for up to $n=35$ to be optimal also within very small tolerance values.

\subsection{Approximation algorithms}

%The problem of finding the smallest square that suffices for packing any set of circles of combined area 1 was posed by .
When \textcite{DFL2010circle} posed \Cref{prb:1}, they also described a straightforward quadtree-based approximation algorithm which can guarantee a packing density of $\pi/16 \approx 0.1963$ when packing circles into a square.

\textcite{MPSSW2014polynomial} devised asymptotic polynomial-time approximation schemes for packing unequal circles into the smallest number of unit bins and for packing circles into a strip of unit width and of minimum height. They first pack “large” circles by solving a semi-algebraic system, then cut the remaining free space into sub-bins, and pack the smaller circles into these bins by starting the same algorithm recursively.

Recently, \textcite{HMS2016bounded} developed an asymptotic approximation algorithm for the online version of the circle bin packing problem.
Their algorithm also differentiates between large and small circles: They pack large circles according to the best known packings of equal circles, while small circles are placed in recursively subdivided hexagonal bins. This approach has an asymptotic competitive ratio of at most 2.4394. They also give a lower bound of 2.2920 for any bounded space algorithm for that problem.

\subsection{Heuristics}

For instances which contain too many circles to determine optimal packings, one can ask for lower bounds for the density of optimal packings, that is, the smallest \emph{known} containers in which the circles can be packed.
Many authors employ heuristics to produce good solutions for circle packing problems.
A considerable amout of work has been put into finding new records, mostly for equal circles. The best known solutions for packing equal circles into squares, circles, rectangles, and other containers are continuously published on Specht's website \url{http://packomania.com} \cite{specht2015packomania}.

The works related to this idea are too numerous to be covered here in their entierty, but we will present some of the more important attempts. As described, these approaches do not give performance guarantees, but give lower bounds on the optimal packing of single instances. Most of the works mentioned here lead to improvements of the best known packings in the literature at the time they were published.

\paragraph{Quasi-human and quasi-physical}

\textcite{GGL1995packing} developed a set of heuristics for packing unequal circles in rectangles, based on enumerating \emph{stable} solutions, where a circle is either on the ground or has two lower contacts. To get out of local optima, they evaluate a variety of approaches, like “shaking down” circles or applying genetic algorithms to improve the stable solutions.

\textcite{GLNO1998dense} propose a \emph{billiard simulation} approach, in which the circles are physically simulated as hard disks, and apply some additional steps to tighten the found packings.

\textcite{BDGL2000improving} model the disks as moving particles with repelling forces, and simulate them using a stragety resembling simmulated annealing.

\textcite{WHZX2002improved} describe a “quasi-physical, quasi-human” approach, which first simulates the circles according to gravity, then finds circles which are "most squeezed", and re-inserts them randomly.

\textcite{HLLX2006new} apply a quasi-human heuristic, which places new circles in gaps of approximately the same size as the circle, and combine it with a self-look-ahead strategy which evalutates how beneficial the coice of a certain placement for each circle is.

\textcite{LB2013packing} apply a metaheuristic called \emph{formulation space search}, which alternates between two different heuristics, to avoid getting stuck in local minima. After that, they finish off with an improvement phase, which swaps circles if this improves the solution.

\textcite{HHY2015action} start with a random configuration of unequal circles in a square, simulate them using a quasi-Newton method to reach a minimum energy state, and then perform swapping steps, to get out of locally optimal solutions. Finally, they do a postprocessing step to increase the result's precision.

\paragraph{Pattern-based}

\textcite{GL1996repeated} indentify various regular patterns for packing equal circles in a square, which produce good results for instances where the number of circles equals certain forms like $k^2$, $k^2-1$, or $k(k+1)$.

\textcite{lubachevsky1997curved} studied \emph{curved hexagonal packings} of equal circles in a circle, a pattern derived from known best packings of circles in hexagons. For large $n$, a curved hexagonal packing was found to be not optimal. Instead, good packings found by the authors seemed to have a curved hexagonally-packed area in the center and an irregular pattern along the periphery.

\subsection{Optimization methods}

Another much-explored idea is to model the packing problem as a set of (mostly nonlinear) inequalities and to solve this system using powerful commercial solvers.

\paragraph{Stochastic optimization}

\textcite{ZD2005effective} combine simulated annealing and tabu search to pack unequal circles into a circle.

\textcite{FMC2015evolutionary} solve the problem of packing unequal circles into a circle using genetic algorithms and other evolutionary approaches. As the evolved solutions are not always valid, they evalutate different repair strategies, like repulsion-based or Delauny-based methods.

\paragraph{Linear optimization}

\textcite{LIE2014approximate} compute approximated solutions to packing circles into rectangles by restricting their coordinates to a regular grid and formulate a binary Linear Problem, where the variables represent the assignment of the circles' centers to the grid nodes.

%\textcite{SY2004mathematical} formulate a method of transitioning from one local optimum to a better one when packing unequal circles into a strip, based on a reduced gradient method.

\paragraph{Nonlinear optimization}

\textcite{ALS2008disk} model the problem of packing circles into a square as a global nonlinear optimization problem and apply a stochastic search method similar to Multistart, which they refer to as \emph{Monotonic Basin Hopping}, and which is inspired by molecular conformation problems. They also adapted this algorithm to pack circles into circular containers \cite{GJLS2009solving}.

\textcite{BS2008minimizing} design packing problems as a smooth nonlinear programming model, and solve them using continuous optimization. They give multiple formulations of the problem, allowing them to pack different-sized circles into circles, squares, strips, rectangles or equilateral triangles and to pack spheres into spheres, cuboids, tetrahedra, pyramids and cylinders.

\textcite{BG2010new} note that, given the contacts of the circle objects with the container's boundary beforehand, the numer of constraints is reduced significantly. They learn this contact information from previously best known solutions in the literature and solve the now overdetermined linear system to get high-precision results.

\chapter{Split Packing}\label{ch:split-packing}

While trying to solve \Cref{prb:1}, we worked on the assumption that it would in fact be possible to pack all circle instances whose area would not exceed that of the two-circle instance shown in \Cref{fig:worst-cases} on \cpageref{fig:worst-cases}.%proposed by \textcite{DFL2010circle}.
When we attempted to find a strategy which could pack this area, many strategies did not work. For example, a shelf-packing based approach inspired by Moon \& Moser's algorithm for packing squares does not work for five equal circles, see \Cref{fig:shelf-fail}.

\fig[6]{shelf-fail}{Shelf-packing does not work for five equal circles. The upper right circle slightly overlaps the middle one.}

At one point, we tried restricting the input instance with the hope that this would make the problem easier. We decided to only allow circles which would have areas equal to a negative power of two of the total available area. This would only allow half-, quarter-, eight-, sixteenth-circles, and so on, in terms of the total circle area $a$. We were surprised to find that these instances were easy to pack!

Imagine starting with the total area $a$ combined into one large circle. It's easy to check that this circle can be packed, simply by placing it in the middle of the square, see the top left of \Cref{fig:easy}. Now, you are allowed to “split” the circle into two half-circles, resulting in the worst-case instance discussed in the introduction. If we also cut the square into halves along the circles' tangent, both circles now are incircles of isosceles right triangles.
%The area of the circle and the area of its surrounding triangle are in a certain ratio to one another. This ratio is constant, so
If you now split any circle in half again, you can also divide its surrounding isosceles right triangle into two smaller ones with half the area, and again the resulting circles are the triangles' incircles.
%you can pack the two resulting circles in two smaller triangles, each of which has half the area of the former triangle. Luckily, these two smaller triangles exactly fit into the larger one, meaning that the two new circles fit into, it as well.
This results in a recursive structure, and the splitting can be repeated as often as neccessary, until you arrive at the desired circle instance. This divide-and-conquer approach to recursively split the set of input circles into subsets is the first key idea of the Split Packing algorithm.

\fig[3]{easy}{Splitting circles in half is easy.}

If we now try to drop the restrictions on the circles, and allow arbitrary instances again, we run into a problem: What if we need to split a circle, but we do not want to split it in half, but make one of the resulting circles larger than the other? We would have to shift our cut to the side, like in the bottom-right of \Cref{fig:easy}. We have to subdivide the triangle into another (smaller-than-half) triangle and a quadrilateral. For the small triangle, we can start another recursion, but it is unclear why we can continue with the recursion for the quadrilateral. Its shape resembles our triangles, but the lower corner is “cut off”. We would need an argument why these “degenerated triangles” do not break our packing strategy.
%why this quadrilateral shape suffices to pack all possible circles in which we could want to split the larger circle at this point.

This is where the second key idea of the Split Packing algorithm comes into play.
When performing the top-level split, we could already decide which circles of the input instance should go above respectively below the cut-line. With the power-of-two instances, it did not matter at all \emph{how} we split the circle set in half, as we could always split it into equally-sized halves.

For general circle instances, we need to proceed more carefully: We are going perform the splitting using an algorithm which resembles greedy scheduling. This will make sure our resulting subgroups are \emph{close} to equal in terms of total area. But if the groups' areas deviate from the targeted 1:1 ratio, we can make additional statements about the minimum circle size in the larger group, which will make the “cut-off corners” irrelevant.

In this chapter, we will detail this process. As we will see, this idea also generalizes to other container types and object shapes.

%The packing algorithm proposed in this thesis is based on two core ideas.

%The first idea is an divide-and-conquer approach. We recursively split the set of input circles into subsets. This results in a top-down approach: At each level, the instance is split into two subsets, which are then packed into smaller containers individually, before they are combined again.

%By combining these ideas, we can construct a method which roughly works like the following: We split the circle instance into two subinstances, and then construct two smaller containers which satisfy two conditions: First, the two containers have to fit into the larger container, and second, one needs to be able to pack one of the two parts into them, respectively.

\section{Definitions}

In this subsection, we introduce a few basic notions, mostly to simplify some of the later proofs.

\begin{definition}
    For the purpose of this thesis, a \emph{shape} is either an open circle or an open polygon (“open” meaning that the shape's boundary is not part of the shape).
\end{definition}

What it means to be able to pack objects in a container is defined as one would intuitively expect:

\begin{definition}
    A \emph{packing} of a set of shapes $S$ in another shape $c$ is an assignment of a translation, a rotation and a reflection to each shape so that

    \begin{itemize}
        \item the pairwise intersections of all shapes in $S$ are empty and
        \item all shapes in $S$ are a subset of $c$.
    \end{itemize}

    We call $S$ the \emph{objects} and $c$ the \emph{container}.
\end{definition}

We continue with some definitions which make it easier to talk about classes of circle instances:

\begin{definition}
    For each $0 \le a$, an \emph{$a$-circle} is a circle with an area of $a$.
\end{definition}

\begin{definition}\label{def:circle-instance}
    A \emph{circle instance} is a multiset of non-negative real numbers, which define the circles' areas. Addition of circle instances is defined like on multisets.
    For any circle instance~$C$, $\mysum(C)$ is the combined area of the instance's circles and $\min(C)$ is the area of the smallest circle contained in the instance.
\end{definition}

For example, for the circle instance $C = \{1,1,2,3\}$, $\mysum(C) = 7$ and $\min(C) = 1$.

\begin{definition}
    $\C$ is the set of all circle instances. $\C(a)$ consist of exactly those circle instances $C$ with $\mysum(C) \le a$. Finally, $\C(a,b)$ consists of exactly those circle instances $C \in \C(a)$ with $\min(C) \ge b$.
\end{definition}

Let us give another example for the last definition, as it is crucial for the rest of this thesis: For any circle instance $C$ contained in $\C(1,1/8)$, the combined area of $C$'s circles is at most~1, and at the same time, each of $C$'s circles is at least an eigth-circle.

Finally, we introduce two definitions which come in handy when discussing worst-case instances:

\begin{definition}
    A shape's \emph{incircle} is the largest circle that can be packed into the shape.
\end{definition}

\begin{definition}
    A shape's \emph{twincircles} is the maximum-area circle instance consisting of two equal circles that can be packed into the shape, see \Cref{fig:twincircles} for an example.% The shape's \emph{twincircle area} is their combined area.
\end{definition}

\fig{twincircles}{The twincircles of an equilateral triangle.}

\section{Greedy splitting}

The method which we use to split the circle instances in half resembles a greedy scheduling algorithm, which is why we call the process \emph{greedy splitting}. The algorithm takes two inputs: The first is an arbitrary circle instance $C$, which is to be split into two groups.

The second is a tuple of two positive factors, which determines the targeted ratio of the resulting groups' total areas. For example, if we wanted to split $C$ into equally sized halves, we could choose the tuple $(1,1)$. The tuple $(\frac 1 2,\frac 1 2)$ would give the same result.
For asymmetric containers, we might want to target a different ratio. For example, if we wanted to make one group three times as large as the other, we could use the tuple $(1,3)$. We call these tuples \emph{split keys}:

\begin{definition}
    A \emph{split key} is a tuple of two positive real numbers.
\end{definition}

\textsc{Split} (\Cref{alg:split}) takes two parameters: The first one is a circle instance, whose circles are assumed to be sorted descendingly by size. The second parameter is the split key. The algorithm then creates two empty “buckets”, and in each step adds the largest remaining circle of the input instance to the “more empty” bucket. We say that a bucket is relatively more empty if the ratio between the sum of its current content and the associated factor of the split key is smaller than the ratio in the other one.
In the simplest case, the split key will actually describe the desired combined area of the two groups, and \textsc{Split} puts the next circle into the group which has the smaller “relative filling level”.

\begin{algorithm}
    \caption{\textsc{Split}$(C,F)$}
    \label{alg:split}
    \begin{algorithmic}
        \Require A circle instance $C$, sorted decendingly by size, and a split key $F = (f_1, f_2)$
        \Ensure Circle instances $C_1, C_2$
        \State $C_1 \gets \emptyset$
        \State $C_2 \gets \emptyset$
        \ForAll{$c \in C$}
            \State $j = \argmin_{i} \frac{\mysum(C_i)}{f_i}$\Comment{Find the index of the more empty bucket.}
            \State $C_j \gets C_j \cup \{c\}$
        \EndFor
    \end{algorithmic}
\end{algorithm}

Although the greedy splitting aims to produce subinstances with area ratios as specified by the split key, of course it will not always be possible to achieve these ratios exactly. If, for example, the input instance consists of few very large circles, it might not be possible to distribute them in the specified ratios.

On the other hand, if the resulting groups' area ratio does deviate from the split key, we gain additional information about the group which has more area than specified in the split key: The more this group exceeds its targeted area, the larger the minimum size of its elements will be.

\begin{lemma}\label{th:min1}
    %For any circle instance $C$ and any split key $F = (f_1, f_2)$, \textsc{Split}$(C,F)$ decomposes $C$ into two circle instances $C_1$ and $C_2$. Set $a_i \coloneqq \mysum(C_i)$ and assume (\wlofg) $\frac{a_2}{f_2} \le \frac{a_1}{f_1}$.
    %Then $\min(C_1) \ge a_1 - f_1\frac{a_2}{f_2}$.

    For any circle instance $C$ and any split key $F = (f_1, f_2)$, \textsc{Split}$(C,F)$ always produces two circle instances $C_1$ and $C_2$ with
    $$\min(C_i) \ge \mysum(C_i) - f_i\min\left\{\frac{\mysum(C_1)}{f_1},\frac{\mysum(C_2)}{f_2}\right\}.$$

    %For any circle instance $C \in \C(a,b)$ and any split key $F = (f_1, f_2)$,
    %\textsc{Split}$(C,(f_1,f_2))$ decomposes any circle instance $C \in \C(a,b)$ into two circle instances $C_1 \in \C(a_1, b_1)$ and $C_2 \in \C(a_2, b_2)$ with

    %\begin{itemize}
    %    \item $C_1 + C_2 = C$
    %    \item $b_1 \ge a_1 - $
    %\end{itemize}
    %. Set $a_i \coloneqq \mysum(C_i)$ and \wlofg assume $\frac{a_2}{f_2} \le \frac{a_1}{f_1}$.
    %Then $\min(C_1) \ge a_1 - f_1\frac{a_2}{f_2}$.
\end{lemma}

\begin{proof}
    Set $r := \min\left\{\frac{\mysum(C_1)}{f_1},\frac{\mysum(C_2)}{f_2}\right\}$. This value describes the smallest “relative filling level” by the time the algorithm ends.

    Now assume for contradicion $C_i$ contained an element smaller than $\mysum(C_i) - f_i r$. As the elements were inserted by descending size, all elements which were put into $C_i$ after that element would have to be at least as small. So the last element put into $C_i$ (let us call it~$c$) would be smaller than $\mysum(C_i) - f_i r$, as well.

    But this means that $\frac{\mysum(C_i) - c}{f_i} > \frac{\mysum(C_i) - (\mysum(C_i) - f_i r)}{f_i} = r$, meaning that at the moment before $c$ was inserted, the relative filling level of $C_i$ would already have been larger than~$r$.
    Recall that $r$ is the smallest filling level of any group by the time the algorithm ends, meaning that at the time when $c$ is inserted, $C_i$'s filling level is already larger than the filling level of the other group.
    %the group's filling level would have been at least as small.
    This is a contradiction, as the greedy algorithm would choose to put $c$ not into $C_i$, but into the other group with the smaller filling level in this case.
    %not have put $c$ into $C_i$, but into the other group with the smaller relative filling level.
    %This is a contradiction to the algorithm's greedy nature, as \textsc{Split} would not have but $c$ into the (fuller) group $C_i$ in this situation.
    %For the minimum size, assume for contradicion that $C_i$ contained an element smaller than $a_i - f_i r$. All elements which were put into $C_i$ after that have to be at least as small, as the elements were inserted by descending size. So the last element put into $C_i$ (let us call it $c$) would be smaller than $a_i - f_i r$, as well.
    %But this means that $\frac{a_i - c}{f_i} > \frac{a_i - (a_i - f_i r)}{f_i} = r$, meaning that at the moment before $c$ was inserted, the relative filling level of $C_i$ would already have been larger than $r$. But $r$ is the smallest relative filling level by the time the algorithm ends, so at the time when $c$ is inserted, the group's filling level would have been at least as small.
    %This is a contradiction to the algorithm's greedy nature, as \textsc{Split} would not have but $c$ into the (fuller) group $C_i$ in this situation.
\end{proof}

We can go even further: If one group's relative filling level becomes twice as large as the other one's, the group must consist of a single circle:

\begin{lemma}\label{th:min2}
    %For any circle instance $C$ and any split key $F = (f_1, f_2)$, \textsc{Split}$(C,F)$ produces two circle instances $C_1$ and $C_2$. Set $a_i \coloneqq \mysum(C_i)$.
    %If $a_1 > 2 f_1 \frac{a_2}{f_2}$, then $|C_1| = 1$ and $\min(C_1) = a_1$.
    For any $C_1$ and $C_2$ produced by \textsc{Split}$(C,(f_1,f_2))$:

    $$\mysum(C_i) > 2f_i\min\left\{\frac{\mysum(C_1)}{f_1},\frac{\mysum(C_2)}{f_2}\right\} \Rightarrow \min(C_i) = \mysum(C_i)$$
\end{lemma}

\begin{proof}
    The condition is equivalent to $\mysum(C_i) - f_i\min\left\{\frac{\mysum(C_1)}{f_1},\frac{\mysum(C_2)}{f_2}\right\} > \frac{\mysum(C_i)}{2}$. So by \Cref{th:min1}, $\min(C_i) > \frac{\mysum(C_i)}{2}$, which means that the minimum size of the circles in $C_i$ is already more than half of its total sum. The only possible instance which satisfies this constraint is a single circle with area $a_i$.

\end{proof}

Note that we usually do need this last property and will ignore the additional constraint on $\min(C_i)$, except in \Cref{ch:rubies}, where we discuss packing objects other than circles.

%Here is a definition that makes it easier to talk about 
%The next definition looks a bit weird, but makes it easier to talk about multiple shapes:
We are now going to define a term which encapsulates all mentioned properties of the circle instances output by \textsc{Split}. These properties depend on the used split key, and also on the total area $a$ and the minimum circle size $b$ of the circle instance, which is why it has three parameters. We say that instances produced by \textsc{Split} are \emph{$(a,b,F)$-conjugated}:

%\begin{definition}\label{def:rounded}
%    For any split key $F$ of length $n$, we say that a tuple of $n$ shapes is \emph{$(F,b)$-rounded}, if the $i$-th shape is a $\C(a_i, \min\{b,a_i - f_i r\})$-shape, with $r = \max\{\frac{a_i}{f_i}|i \in 1,2,\dots,n\}$.
%\end{definition}

\begin{definition}\label{def:conjugated}
    For any $0 \le b \le a$ and any split key $F = (f_1, f_2)$, we say that the tuples $(a_1, b_1)$, $(a_2, b_2)$ are \emph{$(a,b,F)$-conjugated} if

    \begin{itemize}
        \item $a_1 + a_2 = a$,
        \item $b_i \ge b$,
        \item $b_i \ge a_i - f_i \min\left\{\frac{a_1}{f_1}, \frac{a_2}{f_2}\right\}$, and
        \item $a_i > 2 f_i\min\left\{\frac{a_1}{f_1}, \frac{a_2}{f_2}\right\} \Rightarrow b_i \ge a_i$.
    \end{itemize}
    %\begin{itemize}
    %    \item $a_1 + a_2 = a$ and
    %    \item $b_i = \begin{cases}
    %            \max\{b,a_i\} & \text{if}\ a_i > 2 f_i\min\{\frac{a_1}{f_1}, \frac{a_2}{f_2}\}\}\\
    %            \max\{b,a_i - f_i \min\{\frac{a_1}{f_1}, \frac{a_2}{f_2}\}\} & \text{else}
    %        \end{cases}$.
    %\end{itemize}
\end{definition}

\begin{definition}
    Two circle instances $C_1$ and $C_2$ are $(a,b,F)$-conjugated if there are any $(a,b,F)$-conjugated tuples $(a_1, b_1)$ and $(a_2, b_2)$ so that $C_1 \in \C(a_1, b_1)$ and $C_2 \in \C(a_2, b_2)$.
\end{definition}

We can now associate this property with \textsc{Split} in the following theorem:

\begin{theorem}\label{th:split-properties}
    For any $C \in \C(a,b)$ and any split key $F = (f_1, f_2)$, \textsc{Split}$(C,F)$ always produces two $(a,b,F)$-conjugated subinstances.
   % produces two subinstances $C_1 \in \C(a_1, b_1), C_2 \in \C(a_2, b_2)$, so that $C_1 + C_2 = C$ and $(a_1, b_1)$ and $(a_2, b_2)$ are $(a,b,F)$-rounded.
\end{theorem}

\begin{proof}
    That the subinstances' total areas add up to $a$ follows directly from the algorithm.
    %As $\min(C) \ge b$, the subinstances must have the same property.
    As the minimum size of all circles in $C$ is $b$, this must also be true for the subinstances, so $\min(C_i) \ge b$.
    The other two minimum-size properties follow from \Cref{th:min1} and \Cref{th:min2}.
   % Additionally, by \Cref{th:split-property}, $C_i \in \C(a_i, a_i - f_i \min\{\frac{a_1}{f_1}, \frac{a_2}{f_2}\})$. Thus, the subinstances satisfy \Cref{def:rounded}.
\end{proof}

As described, one way to think about conjugatedness is that it gives guarantees for the minimum sizes of the “larger” produced subinstance.

(TODO: graph of sum(Ci) vs min(Ci))

%What is means for shapes to be $(F,b)$-rounded is that we lift some requirements on which instances they need to be able to pack. We combine two lower bounds for the minimum size of the instances: First, the shapes never need to be able to pack any instances containing circles smaller than $b$. Second, they reflect the \textsc{Split}-algorithm's minimum element sizes stated in \Cref{th:split-property}. If a subinstance $C_i$ returned by \textsc{Split} can not possibly contain any circles smaller than a certain size, it makes sense to also relax the requirements for the shapes in which these subinstances will be packed: It suffices if they can pack those instances where the circles have this minimum size. Whichever of the two circle sizes requirements is largest, determines the “minimum size” of the rounded shape.

%Put differently, to have $F$-rounded shapes of the correct totals is a sufficient condition to be able to pack resulting subinstances of a \textsc{Split} operation into them. This is expressed in the following lemma:

\section{Split Packing}

The \textsc{Split} algorithm presented in the previous section, as well as the properties of the instances it produces, are the foundations on which we will build the central theorem of this thesis: The Split Packing theorem. Split Packing by itself is a general approach to pack circles and other shapes into containers. The later chapters of this thesis will all apply Split Packing to different object and container shapes.

First, another definition. We will often want to state that a shape can pack all circle instances which belong to a certain class. For this, we define the term \emph{$\mathcal{C}$-shape}:

\begin{definition}
    For any $\mathcal{C} \subseteq \C$, a \emph{$\mathcal{C}$-shape} is a shape in which each $C \in \mathcal{C}$ can be packed.
\end{definition}

For example, if a shape is a $\C(a)$-shape, it means that it can pack all circle instances with a total area of $a$. And a $\C(a,b)$-shape can pack all circle instances with a total area of $a$, whose circles each have an area of at most $b$.
With these preparations, we can now state our central theorem:

%For convenience, we define the \emph{sum} of a $\C(a)$-shape:

%\begin{definition}
%    For a $\C(a)$-shape, we call $a$ the shape's \emph{sum}.
%\end{definition}

%We also extend our definition of conjugatedness to shapes:
%
%\begin{definition}
%    We say that $n$ shapes are $(F,b)$-rounded if they are a $\C(a_1, b_1)$-shape and a $\C(a_2, b_2)$-shape and their parameter tuples are $(F,b)$-rounded.
%\end{definition}

%Recall that $\C(a,b)$ contains all circle instances with a sum of $a$ and a minimum circle size of $b$. If a shape is a $\C(a,b)$-shape with $b > 0$, it means that it can pack all circle instances $C$ with $\mysum(C) \le a$ and $\min(C) \ge b$. This leads to an interesting effect: As the shape does not need to accomodate for circles smaller than $b$, it can be “rounded” to a radius of a $b$-circle. Sharper corners will be superfluous, as circles in $\C(a,b$) will not be permitted to be placed there anyway.
%In particular, this means that the shape's maximum local curvature can be the curvature of a $b$-circle, as when the curvature is 


%\begin{theorem}
%    A shape is a $\mathcal{C}$-shape, if, for a given decomposition method, for all possible decompositions $C_1, C_2, \dots, C_n$ of any $C \in \mathcal{C}$, one can always find $n$ shapes in which the resulting subinstances can be packed, and which fit into the original shape.
%\end{theorem}

%\begin{theorem}
%    A shape is a $\C(a,b)$-shape, if there is a split key $F$, so that for all $a_1 + a_2 + \dots + a_n \le a$, one can find a $\C(a_1)$-shape, a $\C(a_2)$-shape, \dots, and a $\C(a_n)$-shape, which are $F$-rounded and fit into the original shape.
%\end{theorem}

%\begin{lemma}\label{th:split-rounded}
%    Given an arbitrary $C \in \C(a,b)$ and a split key $F$, use \textsc{Split}$(C,F)$ to decompose $C$ into $n$ subinstances. Call the subinstances' totals $a_1$, $a_2$, \dots, $a_n$. If we can find a $\C(a_1, b_1)$-shape, a $\C(a_2, b_2)$-shape, \dots, and a $\C(a_n, b_n)$-shape, so that the shapes' parameters are $(F,b)$-rounded, we can pack $C$ into the shapes.
%\end{lemma}
%
%\begin{proof}
%    We know from \Cref{th:split-sets} that \textsc{Split} only produces subinstances $C_i \in \C(a_i, b_i)$ so that the instance set's parameters are $(F,b)$-rounded. As the $i$-th shape is a $\C(a_i, b_i)$ shape, we can pack $C_i$ into it.
%\end{proof}

\begin{theorem}[Split Packing]\label{th:split-packing}
    %For a given shape $s$, and for any $0 \le b < a$, if there is a split key $F$, so that for all tuples $(a_1, a_2)$ with $a_1 + a_2 \le a$
    %one can find $n$ $(a,b,F)$-conjugated shapes of matching sums,
    %and these shapes can be packed into $s$, then $s$ is a $\C(a,b)$-shape.

    %For any shape $s$, and for any $0 \le b < a$, if there is a split key $F$, so that 
    %for all $(a,b,F)$-conjugated pairs of tuples $(a_1, b_1)$ and $(a_2, b_2)$ one can find a $\C(a_1, b_1)$-shape and a $\C(a_2, b_2)$-shape which can be packed into $s$,
    %%then all circle instances with a total area of at most $a$ and a minimum circle size of $b$ can be packed into $s$.
    %then $s$ is a $\C(a,b)$-shape.

    A shape $s$ is a $\C(a,b)$-shape if there is a split key $F$, so that for all $(a,b,F)$-conjugated tuples $(a_1, b_1)$ and $(a_2, b_2)$ one can find a $\C(a_1, b_1)$-shape and a $\C(a_2, b_2)$-shape which can be packed into $s$.

    %then all circle instances with a total area of at most $a$ and a minimum circle size of $b$ can be packed into $s$.
\end{theorem}

\begin{proof}
    Consider an arbitrary $C \in \C(a,b)$.
    We use \textsc{Split}$(C,F)$ to produce two smaller non-empty subinstances $C_1$ and $C_2$. We know from \Cref{th:split-properties} that those subinstances will always be $(a,b,F)$-conjugated. So if we can indeed find two shapes which can pack these subinstances, and if we can pack these two shapes into $s$, then we also can pack the original circle instance $C$ into $s$.
    %As these shapes also fit into $s$, we know that we can pack $C$ into $s$.

    Note that in the extreme case that $C$ consists of a single circle, \textsc{Split}$(C,F)$ will yield two circle instances $C_1 = C$ and $C_2 = \emptyset$. For this case, \Cref{th:split-properties} guarantees a minimum size of $a$ for the first group, and the associated shape is just an $a$-circle. This means that we can simply place the input circle in the container, and stop the recursion at this point.
\end{proof}

%As this theorem is of central importance for the whole thesis, let us rephrase it: \Cref{th:split-packing} describes what is sufficient to proof that a shape can pack all circle instances whose total area does not exceed $a$, and which have a minimum circle size of $b$: First, find a shape-specific split key $F$ and show that for all possible pairs of tuples $(a_1, b_1)$ and $(a_2, b_2)$

%decompositions of the area $a$ (which is going to be perfomed by \textsc{Split}), that one can find $(F,b)$-rounded shapes of matching sums that fit into the original shape.

Written as an algorithm, Split Packing looks like this:

\begin{algorithm}
    \caption{\textsc{Splitpack}$(s,C)$}
    \begin{algorithmic}
        \Require A $\C(a,b)$-shape $s$ and a circle instance $C \in \C(a,b)$, sorted decendingly by size
        \Ensure A packing of $C$ into $s$
        \State Determine split key $F$ for shape $s$
        \State $(C_1, C_2) \gets \textsc{Split}(C,F)$ \Comment{See \Cref{alg:split}.}
        %\State $(s_1, s_2) \gets$ any $(F,b)$-rounded shapes with $\mysum(s_i) = \mysum(C_i)$
        \ForAll{$i \in \{1,2\}$}
            \State $a_i \gets \mysum(C_i)$
            \State $b_i \gets$ minimum guarantee for $C_i$ \Comment{See \Cref{def:conjugated}.}
            \State Determine a $\C(a_i, b_i)$-shape $s_i$
            \State \Call{Splitpack}{$s_i, C_i$}
        \EndFor
        \State Pack $s_1$, $s_2$, and their contents into $s$
    \end{algorithmic}
\end{algorithm}

To summarize, to apply \textsc{Splitpack} to a shape, we need the following elements:

\begin{enumerate}
    \item A strategy to determine the shape-specific split key $F$.
    \item A strategy to determine a $\C(a_1, b_1)$-shape and a $\C(a_2, b_2)$ for all $(a,b,F)$-conjugated tuples $(a_1, b_1)$ and $(a_2, b_2)$.
    \item A strategy to pack these two shapes into $s$, and a proof why this always works.
\end{enumerate}

Note that the Split Packing algorithm can easily be extended to allow splitting into more than two subgroups. For simplicity, we only describe the case of two subgroups here, as splitting into two groups suffices for the shapes we discuss in this thesis.

%\section{Normalization}

%In some proofs, we will normalize the instances, shapes, or figures in question. For example, we can scale all areas involved up by a factor of $f$, as long as we scale all lengths up by a factor of $\sqrt{f}$.

\section{Analysis}

There are two perspectives on Split Packing. Say that we have all elements in place so that we know we can use Split Packing to pack each circle instance in $\C(a)$ into a shape of densit

First, it can give sufficient conditions for the decision problem if a given circle instance can be packed into a given container: If the circles have a combined area of at most $a$, the instance can be packed.

But second, it can also be used as an approximation algorithm. Say you are given a circle instance of total area $a$. The task is to find the smallest container of a certain family (for example, triangular or square) in which the instance can be packed. Again, \textcite{DFL2010circle} proved it to be NP-hard to find the minimum-area container, but we can use the Split Packing algorithm for an approximation: Select a $\C(a)$-shape with a guaranteed packing density of $d$.
%where the ratio between $a$ and the shape's area $APX$ (we call the ratio $a/APX$ the \emph{packing density}) is as high as possible.

\paragraph{Approximation factor}

We can be sure that the area of the optimal container $OPT$ needs to be as least $a$:

$$OPT \ge a$$

At the same time, the area of the approximated container $APX$ is exactly $a/d$:

$$APX = a/d$$

which means that

$$APX/OPT \le = 1/d$$

\subsubsection{Runtime}

Before \textsc{Splitpack} is first invoked, the circle instance has to be sorted descendingly by size, this can be done in $O(n log n)$ time. Each run of the \textsc{Split} subroutine takes linear time in the size of its input. In the worst case, each run splits off only one element, so that ...

$O(n log n)$ for sorting, after that $O(n^2)$, I think

table of factors

Diagram for triangles

\chapter{Packing circles}\label{ch:circles}

In the last chapter, we described how Split Packing works in general. In this chapter, we turn to specific types of container shapes: Triangles and Rectangles. For each shape, we will demonstrate two properties: First, we will argue about the \emph{worst-case circle instance} in terms of the density of its optimal packing. This instance constitutes an upper bound to the question “How much area can always be packed?”, because we can show that, given more area, we can find instances which \emph{cannot} be packed.

Second, we are going to show how Split Packing can pack all instances of this area into the shape. This is a constructive way to show a lower bound to our problem. Both pieces together give the answer to \Cref{prb:1}: We have found the largest area $a$, so that circles with this combined area can always be packed into the shape, and we have a polyominal-time algorithm that actually realizes the packing.

As described in the beginning of the last chapter, Split Packing was originally designed to pack circles, so in this chapter, our objecs will always be circles.

%are going to proof the \emph{worst-case packing density}. In each case, we are going to give a circle instance with combined area $a$ and show two properties: First, that for all $a' > a$, there are circle instances of combined area $a'$ which \emph{cannot} be packed. Second, that all instances of combined area $a$ can be packed.

\section{Hats}

We saw in \Cref{ch:split-packing} that when applying \textsc{Split} to a circle instance, we can often make a statement about the minimum circle size of one group.
If you think about how a circle of minimum size can be placed in the container, there might be certain points which can never be covered by a circle without overlapping the container's boundary. For example, if the container's boundary contains sharp angles, you can not use all of the area inside of that angle, as the minimum circle might be too large to cover all of its points. As we can not use such points for packing the circle instance, we might as well remove it from the container without changing its packing capabilities.

TODO fig

Technically, you can calculate the usable area of a container shape by first eroding it by a circle of minimum size, and then dilating the result with the same circle.

This observation motivates a family of shapes which resemble triangles whose corners are rounded. We call these shapes \emph{hats}:

\begin{definition}
    For each $0 \le b \le a$, an \emph{$(a,b)$-hat} is a non-acute triangle with an incircle of area $a$, whose corners are rounded to the radius of a $b$-circle, see \Cref{fig:hat}.
    Call the two lower angles of the original triangle \emph{left-angle} and \emph{right-angle}.
    If we say \emph{right hat} or \emph{obtuse hat}, the hat is based on a right/obtuse triangle.
\end{definition}

\newcommand\defaulta{30}
\newcommand\defaultb{40}
\newcommand\defaultr{0.2}
\newcommand\defaultx{0.7}

\fig[3]{hat}{An $(a,b)$-hat.}

\begin{definition}\label{def:hat-split-key}
    To get a hat's \emph{associated split key}, split the underlying triangle orthogonally to its base through its tip, and inscribe two circles in the two sides, see \Cref{fig:hat-f}.
\end{definition}

\fig{hat-f}{A hat's \emph{associated split key} equals $(f_1, f_2)$}

To prepare for the next proof, we establish the following lemma:

\begin{lemma}\label{th:overlap}
    Place two circles of combined area $a$ in two corners of a triangle, like in \Cref{fig:hats-overlap}. Let $w$ be the length of the connecting side of the triangle. Now, define $p_1$ and $p_2$ to be the “projection factors”, so that, when projecting circle $a_i$ down onto the connecting side, the distance between the triangle's corner and the far point of the projection is $\sqrt{a_i}p_i$. The two projections do not intersect if

    $$w \ge \sqrt{a(p_1^2 + p_2^2)}.$$
\end{lemma}

\begin{proof}
    Let $w'(a_1) = \sqrt{a_1}p_1 + \sqrt{a-a_1}p_2$ be the combined width of both projections. This function has its global maximum at $a_1 = \frac{p_1^2}{p_1+p_2}a$, and the maximum value is $\sqrt{a(p_1^2+p_2^2)}$. If $w$ is at least as large as this value, the two projections do never intersect.
\end{proof}

\fig{hats-overlap}{text}

\begin{lemma}\label{th:hats-in-hat}
    Consider an $(a,0)$-hat with the associated split key $F = (f_1, f_2)$, and call its left- and right-angles $\alpha$ and $\beta$.
    For all $(a,0,F)$-conjugated tuples $(a_1, b_1)$ and $(a_2, b_2)$, the following two shapes can be packed into the hat:
    \begin{itemize}
        \item A right $(a_1,b_1)$-hat with a right-angle of $\alpha$ and
        \item a right $(a_2,b_2)$-hat with a left-angle of $\beta$.
    \end{itemize}
\end{lemma}

\begin{proof}
    Place the hats' tips at the bottom of the container hat, rotate their $\alpha$- and $\beta$-angles towards the container's matching angles and push them as far to the left/right as possible. \Cref{tab:hats-in-hat} illustrates how these packings looks like for different values of $a_1$ and~$a_2$ and gives some informal reasoning why they can always be packed.

    \begin{table}
        \caption{Hat-in-hat packings for different values of $a_1$ and $a_2$}
        \label{tab:hats-in-hat}

        \begin{tabular}{cp{7cm}}
            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{1}{0}
            \end{tikzpicture}
            & When $a_2 = a$, the second hat is simply rounded to a circle of area $a$. By definition, this is the incircle of the container, so it can be packed.\\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.9}{0}
            \end{tikzpicture}
            & As $a_2$ gets smaller, the second hat gets less rounded, but still enough so that it can be packed. The other hat is a non-rounded triangle, which fits beside the second one.\\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.7}{0}
            \end{tikzpicture}
            & \\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.6}{0}
            \end{tikzpicture}
            & \\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.43}{0}
            \end{tikzpicture}
            & When $a_1$ and $a_2$ have a ratio as specified by the container's associated split key, the two hats are both not rounded, but they can still be packed.\\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.3}{0}
            \end{tikzpicture}
            & When $a_2$ gets smaller than specified by the split key, it is now the first container which is getting more rounded.\\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0.1}{0}
            \end{tikzpicture}
            & As $a_1$ approaches $a$, it is now the first hat whose shape gets closer to a perfect $a$-circle.\\

            \begin{tikzpicture}[scale=1.8,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \hatsinhat{\defaulta}{\defaultb}{0}{0}
            \end{tikzpicture}
            & By the same argument as before, this circle can be packed.\\
        \end{tabular}
    \end{table}

    This way of placing the two hats results in a valid packing if (1) the hats do not overlap each other and (2) the hats fit into the hat individually. We are going to proof these two properties separately.

    We first want to show that the hats do not overlap each other. If the hats' projections onto the container's base do not overlap, we found a seperating axis and can be sure that the hats do not overlap, as well. Furthermore, because the hats' incircles touch the rightmost part of the left hat's boundary and the leftmost part of the right hat's boundary, it suffices to show that the projections of the hats' incircles onto the container's base do not overlap.

    (TODO: pic)

    We want to use \Cref{th:overlap} for this proof, so we need to make a statement about the projection factors $p_1$ and $p_2$ in \Cref{fig:hatlr}: If the top angle is a right angle, we can see that $\sqrt{a}p_1 = x$ and $\sqrt{a}p_2 = y$. So by the Pythagorean theorem, $w^2 = (\sqrt{a}p_1)^2 + (\sqrt{a}p_2)^2$.
     If the top angle is more obtuse, but the incircle's center stays at the same $x$-coordinate (like the dotted variant in \Cref{fig:hatlr}),
    both $\sqrt{a}p_1$ and $\sqrt{a}p_2$ only get smaller, so for each hat, $w^2 \ge (\sqrt{a}p_1)^2 + (\sqrt{a}p_2)^2$, which is equivalent to $w \ge \sqrt{a(p_1^2+p_2^2)}$.
    By \Cref{th:overlap} this means that the projections of the circles do not overlap.

    \fig{hatlr}{$l^2 + r^2 \le 1$ holds for each non-acute triangle}

    The second property we need to show is that the hats fit into the container individually. Unfortunately, this part of the proof is going to be long and technical.

    If a hat's incircle is not larger than the incircle of the container hat's side, it will fit into the container without question because it is a subset of that side (like all the non-rounded hats in \Cref{tab:hats-in-hat}).
    So let us assume $a_i > f_i$.

    In this proof, we use two different length-area ratios, which are illustrated in \Cref{fig:hat-poke-f}. The first one is $d$, which describes the ratio between the length of the triangle's right leg and the area of its right incircle $f_i$. Note that for all triangles \emph{similar} to the right part of the container triangle, this ratio between the length of this edge and the square root of the incircle's area will be constant.
    %For hats similar to the container hat's right side, the ratio between the square root of its incircle's area and the length of its base is constant. We call this constant $d$.
    %Also, we are interested in the fraction $\frac{x}{d}$ in \Cref{fig:hat-poke-f}, which specifies “which fraction of the longest side of a triangle similar to the container's right side is above a tangent to its incircle parallel to the container triangle's left side”. We can observe that
    The second ratio, $e$, is the ratio between the length of the same right leg and the incircle-area of the whole container triangle. Again, if formulated as a quotient between the length of this edge and the square root of the incircle, it is a constant for triangles similar to the given container triangle. Note that, in preparation for a generalization later in this chapter, we denote the triangle's incircle by $o$.
    From \Cref{fig:hat-poke-f} we can also observe that
    $e\sqrt{o} = d\sqrt{f_i}$, which is equivalent to $e = d\sqrt{\frac{f_i}{o}}$.

    \fig{hat-poke-f}{The ratios $d$ and $e$ are constant for all similar triangles.}


    %$$\frac{x}{d} = \frac{d-d\sqrt{f_i})}{d} = 1 - \sqrt{f_i}$$

    Moving forward, in \Cref{fig:hat-poke}, we display the situation when packing a hat into (\wlofg) the right side of the container. $f_i$ is the relevant factor from the split key, $a_i$ is the hat's incircle and $b_i$ represents the hat's rounding.

    \fig{hat-poke}{Various measurements when packing a rounded hat.}

    The hat is placed in such a way that it will never overlap the bottom or the right side of the containing triangle, so it is sufficient to show that it does not overlap the left side.
    We can tell from \Cref{fig:hat-poke} that this does not happen if right leg of the triangle the hat is based on ($d\sqrt{a_i}$), minus the right leg of the $(b_i,0)$-triangle similar to the containers right side ($d\sqrt{b_i}$), plus the right leg of the $(b_i,0)$-triangle similar to the container ($e\sqrt{b_i}$) is at most the length of the container right leg ($d\sqrt{f_i}$):

    \begin{equation*}
        d\sqrt{a_i} - d\sqrt{b_i} + e\sqrt{b_i} \le d\sqrt{f_i}
    \end{equation*}

    As observed above, $e = d\sqrt{f_i/o}$:

    \begin{equation*}
        d\sqrt{a_i} - d\sqrt{b_i} + d\sqrt{f_i/o}\sqrt{b_i} \le d\sqrt{f_i}
    \end{equation*}

    In our case, $o = a$. But even if $o \ge a$, the inequality is true if

    \begin{equation*}
        d\sqrt{a_i} - d\sqrt{b_i} + d\sqrt{f_i/a}\sqrt{b_i} \le d\sqrt{f_i}
    \end{equation*}

    We can also divide by $d$ and factor out $\sqrt{b_i}$ to get:

    \begin{equation}\label{eq:tripoke}
        \sqrt{a_i} - (1-\sqrt{f_i/a})\sqrt{b_i} \le \sqrt{f_i}
    \end{equation}


    Let $j$ be the index of the other hat to be packed.
    We know (from the conjugatedness) that the sum of both hats' incircles does not exceed the total area $a$: $a_i + a_j \le a$. Also, $f_i + f_j \ge a$, as demonstrated in \Cref{fig:hat-f-sum}: In right triangles, $f_1 + f_2$ is exactly $a$, because as its two halves are \emph{similar} to the large triangle. When making the upper angle more obtuse, but letting $f_1$ and $f_2$ stay the same, the incircle only shrinks.

    \fig[3]{hat-f-sum}{In non-acute triangles, $f_1 + f_2 \ge a$.}
    %Since we assumed $a_i > f_i$, the inequalities $a_i - a_if_i > f_i - a_if_i$ and $\frac{a_i}{f_i} > \frac{1-a_i}{1-f_i} \ge \frac{a_j}{f_j}$ are also true, which means that the relative filling level of group $j$ is lower than that of group~$i$.
    So by \Cref{th:split-properties}, our hat it is rounded by

    $$b_i \ge a_i - f_i\frac{a_j}{f_j} \ge a_i - f_i\frac{a-a_i}{a-f_i} = \frac{a_i(a-f_i)-f_i(a-a_i)}{a-f_i} = a\frac{a_i-f_i}{a-f_i}$$

    Insert that into \Cref{eq:tripoke}:

    $$\sqrt{a_i} - (1-\sqrt{f_i/a})\sqrt{a\frac{a_i-f_i}{a-f_i}} \le \sqrt{f_i}$$

    Then bring the subtrahend to the right and square both sides (both are positive):

    $$a_i \le f_i + 2\sqrt{f_i}(1-\sqrt{f_i/a})\sqrt{a\frac{a_i-f_i}{a-f_i}} + (1-\sqrt{f_i/a})^2a\frac{(a_i-f_i)}{a-f_i}$$

    Subtract $f_i$ and divide by $\sqrt{a_i-f_i}$:

    $$\sqrt{a_i-f_i} \le \frac{2\sqrt{f_i}(1-\sqrt{f_i/a})\sqrt{a}}{\sqrt{a-f_i}} + (1-\sqrt{f_i/a})^2a\frac{\sqrt{a_i-f_i}}{a-f_i}$$

    Rearrange:

    $$\sqrt{a_i-f_i}\frac{(a-f_i)-(1-\sqrt{f_i/a})^2a}{a-f_i} \le \frac{2\sqrt{f_i}(1-\sqrt{f_i/a})\sqrt{a}}{\sqrt{a-f_i}}$$

    Simplify:

    $$\sqrt{a_i-f_i}\frac{2\sqrt{f_ia}-2f_i}{a-f_i} \le \frac{2\sqrt{f_ia}-2f_i}{\sqrt{a-f_i}}$$

    Then multiply with $\sqrt{a-f_i}$:

    %$$\sqrt{a_i-f_i}\frac{(1-f_i)-(1-\sqrt{f_i})^2}{\sqrt{a-f_i}} \le \frac{(1-f_i)-(1-\sqrt{f_i})^2}{\sqrt{a-f_i}}\sqrt{a-f_i}$$
    $$\sqrt{a_i-f_i}\frac{2\sqrt{f_ia}-2f_i)}{\sqrt{a-f_i}} \le \frac{2\sqrt{f_ia}-2f_i}{\sqrt{a-f_i}}\sqrt{a-f_i}$$

    Finally, divide by the large fraction to get:

    \begin{equation*}
        \sqrt{a_i-f_i} \le \sqrt{a-f_i} \iff a_i - f_i \le a - f_i \iff a_i \le a
    \end{equation*}

    As $a_i$ is never larger than $a$, \Cref{eq:tripoke} is true and the hat always fits into the container. This completes the proof of \Cref{th:hats-in-hat}.
\end{proof}

Until now, the container was always an $(a,0)$-hat, which is essentially a non-rounded triangle with an incircle of $a$. The next lemma extends this idea to hats which are actually rounded. It is identical to \Cref{th:hats-in-hat}, except that that the rounding of the container hat is no longer 0, but $b$.

\begin{lemma}\label{th:rounded-hats-in-hat}
    Consider an $(a,b)$-hat with the associated split key $F = (f_1, f_2)$, and call its left- and right-angles $\alpha$ and $\beta$.
    For all $(a,b,F)$-rounded tuples $(a_1, b_1)$ and $(a_2, b_2)$ with $a_1 + a_2 \le a$, the following two shapes can be packed into the hat:
    \begin{itemize}
        \item A right $(a_1,b_1)$-hat with a right-angle of $\alpha$ and
        \item a right $(a_2,b_2)$-hat with a left-angle of $\beta$.
    \end{itemize}
\end{lemma}

\begin{proof}
    \Cref{th:hats-in-hat} tells us that this theorem is true for $b = 0$. Now, the container's corners can be rounded to the radius of a $b$-circle, and we need to show that the two hats from the previous construction still fit inside. But all of the two hat's corners are also rounded to (at least) the same radius (see \Cref{th:split-properties}), so they will never overlap the container, see \Cref{fig:hats-rounding}.
\end{proof}

\fig{hats-rounding}{Rounding all hats' corners by the same radius does not affect the packing.}

With these preparations, we can finally apply Split Packing to hats:

\begin{theorem}\label{th:hats}
    Given an $(a,b)$-hat, all circle instances with a combined area of at most $a$ and a minimum circle size of at least $b$ can be packed into that triangle.
\end{theorem}

\begin{proof}
    We proof by induction that we can pack each $C \in \C(a,b)$ into the hat:

    If $C$ only consists of a single circle, it can be packed into the hat, as it is as most as big as the hat's incircle.

    Now assume that for any $0 \le b \le a$, any $(a,b)$-hat could pack all circle instances in $\C(a,b)$ with at most $n$ circles. Consider a circle instance $C \in \C(a,b)$ containing $n+1$ circles.
    \Cref{def:hat-split-key} tells us how to compute the split key $F$.
    Then we know from \Cref{th:split-properties} that \textsc{Split} will partition $C$ into two subinstances $C_1 \in \C(a_1, b_1)$ and $C_2 \in \C(a_2, b_2)$, whose parameters are $(a,b,F)$-rounded. As \textsc{Split} can never return an empty instance (except for $|C| = 1$, a case which we handled above), each subinstance will contain at most $n$ circles. We know from \Cref{th:rounded-hats-in-hat} that, for all pairs of $(a,b,F)$-rounded tuples, we can find two hats with matching parameters which fit into the container hat. By assumption, these hats can now pack all instances from $\C(a_1, b_1)$ and $\C(a_2, b_2)$, respectively, which means that they can especially also pack $C_1$ and $C_2$. If we then pack the two hats in the container, we have connstructed a packing of $C$ into the container hat.

    By induction, we can pack each $C \in \C(a,b)$ into the $(a,b)$-hat.
\end{proof}

\section{Non-acute triangles}

This section is going to be short, as non-acute triangles are only a special case of a hat.

\begin{theorem}\label{th:tri}
    Given a non-acute triangle with an incircle of area $a$, all circle instances with a combined area of up to $a$ can be packed into the triangle, and this bound is tight. Expressed algebraically, for a triangle with side lengths $a$, $b$, and $c$, the density bound is

    $$\sqrt{\dfrac{-(a-b-c)(a+b-c)(a-b+c)}{(a+b+c)^3}}\pi < 53.91\%.$$
\end{theorem}

\begin{proof}
    The triangle is an $(a,0)$-hat, which by \Cref{th:hats} is a $\C(a)$-shape.

    On the other hand, a single circle of area $a + \varepsilon$ can not be packed, as the the incircle is by definition the largest circle which fits into the triangle.

    As for the algebraic formulation of the density bound, the area of the triangle can be calculated using Heron's formula:

    $$\Delta(a,b,c) := \sqrt{s(s-a)(s-b)(s-c)} \text{ with } s = \frac{a+b+c}{2}$$

    It is also known that the radius of the incircle of this triangle is

    $$R(a,b,c) := \frac{\Delta(a,b,c)}{s} \text{ with } s = \frac{a+b+c}{2},$$

    so the incircle has an area of

    $$I(a,b,c) = \pi R(a,b,c)^2 = \frac{(a+b-c)(c+a-b)(b+c-a)}{4(a+b+c)}.$$

    Finally, the ratio between the circle's and the triangle's area can be calculated to be

    $$\frac{\pi R(a,b,c)^2}{\Delta(a,b,c)} = \sqrt{\dfrac{-(a-b-c)(a+b-c)(a-b+c)}{(a+b+c)^3}}\pi.$$
\end{proof}

%\fig{triangle-worst}{Worst-case circle instance for a triangle in terms of packing density.}

\section{Isosceles triangles}

Split Packing gives worst-case optimal results not only for non-acute triangles, but also for isosceles triangles, as long as its two symmetric sides are not longer than the base. In this sense, it works for all triangles inbetween a right isosceles triangle and an equilateral triangle.

\begin{definition}
    A \emph{thick isosceles triangle} is an isosceles triangle whose legs are at most as long as its base, but whose top angle is at least $\pi/4$. Examples are shown in \Cref{fig:iso-range}.
\end{definition}

\fig[1]{iso-range}{Range of considered isosceles triangles.}

To prove the worst case for these triangles, we first make a statement about a triangle's \emph{twin circles}:

\begin{lemma}\label{th:iso-worst}
    Two touching equal circles, placed in the corners connected by a triangle's longest side, are the triangle's twincircles, meaning there are no two larger equal circles which can be packed.
\end{lemma}

\begin{proof}
    Call the circle's radius $r$.
    When eroding the triangle by $r$, the remaining area is a triangle similar the the original one, whose longest side has a length of $2r$, see \Cref{fig:twincircles-construction}. This means that when eroding the triangle by $r+\varepsilon$, the longest side of the remaining area must be shorter than $2r$.
    But to pack two circles with radius $r+\varepsilon$, their centers need to be placed at least $r+\varepsilon$ away from the triangle's boundary and at least $2r+2\varepsilon$ away from each other. The construction shows that this is not possible.
\end{proof}

\fig{twincircles-construction}{Two circles larger than these can not be packed.}

In the previous section, the target area $a$ which we wanted to pack always was the area of the triangles incircle. For thick isosceles triangles, the twincircle area, constituting an upper bound for the always-packable area, is \emph{smaller} than the incircle, which means it will not always be possible to pack the area of the incircle.

In this section, we will argue that we can always pack the twincircle area into thick isosceles triangles.

\begin{definition}
    The split key of an isosceles triangle is $(1,1)$.
\end{definition}

\begin{lemma}\label{th:hats-in-iso}
    Consider a thick isosceles triangle with a twincircle area of $a$ and call its symmetric angles $\alpha$.
    For all $(a,0,(1,1))$-conjugated tuples $(a_1, b_1)$ and $(a_2, b_2)$, the following two shapes can be packed into the hat:
    \begin{itemize}
        \item A right $(a_1,b_1)$-hat with a right-angle of $\alpha$ and
        \item a right $(a_2,b_2)$-hat with a left-angle of $\alpha$.
    \end{itemize}
\end{lemma}

\begin{proof}
    Firstly, we show that the hats do not intersect each other: In any isosceles triangle, the projection factors for both sides are equal. So in \Cref{fig:iso-width}, we construct the width of the triangle's base to be $2\sqrt{a/2}p_1 = \sqrt{2ap_1^2} = \sqrt{a(p_1^2+p_2^2)}$. By \Cref{th:overlap}, this means that the hats do not overlap.

    \fig{iso-width}{The width of an isosceles triangle is $\sqrt{2ap_1^2}$.}

    Secondly, we show that the hats do not intersect the container. We are going to re-use the proof from \Cref{th:hats-in-hat} here. On \cpageref{eq:tripoke}, we showed that the hats do not overlap the container if certain conditions are met. These conditions are also true here:

    \begin{itemize}
        \item $a_1 + a_2 \le a$, the hat's incircles add up to at most $a$ because of the conjugatedness of the tuples.
        \item $f_i + f_j \ge a$, in this case, the incircles of the triangles sides are equal to $a$ by assumption.
        \item $o \ge a$, meaning that the triangles incircle is at least as large as the area of the twincircles. This can be demonstrated like in \Cref{fig:hat-f-sum} on \cpageref{fig:hat-f-sum}, but in the reverse direction: For a right isosceles triangle, the twincircle area $a$ is exactly equal to the triangle's incircle. If leaving the twincircles in place, but increasing the top angle, the incircle only gets larger.
    \end{itemize}

    So also in this case, the hats do not overlap the container. This concludes the proof.
\end{proof}

\begin{table}
    \caption{Packing two hats into an isosceles triangle.}
    \label{tab:hats-in-hat}

    \begin{tabular}{cp{10cm}}
        \vspace{10pt}

        \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
            \hatsinhat[1.244]{60}{60}{0.5}{0}
        \end{tikzpicture}
        & Blaha \\

        \vspace{10pt}

        \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
            \hatsinhat[1.244]{60}{60}{0.45}{0}
        \end{tikzpicture}
        & \\

        \vspace{10pt}

        \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
            \hatsinhat[1.244]{60}{60}{0.4}{0}
        \end{tikzpicture}
        & \\

        \vspace{10pt}

        \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
            \hatsinhat[1.244]{60}{60}{0.2}{0}
        \end{tikzpicture}
        & \\

        \vspace{10pt}

        \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
            \hatsinhat[1.244]{60}{60}{0}{0}
        \end{tikzpicture}
        & \\

        \vspace{10pt}
    \end{tabular}
\end{table}

\begin{theorem}
    Given a thick isosceles triangle with a twincircle area of $a$, all circle instances with a combined area of up to $a$ can be packed into the triangle, and this area bound is tight. Expressed algebraically, the density bound is

    $$\frac{(a-2b+\sqrt{4b^2-a^2})^2\pi}{2a\sqrt{4b^2-a^2}}.$$
\end{theorem}

\begin{proof}
    By \Cref{th:hats-in-iso} and the Split Packing Theorem, the triangle is a $\C(a)$-shape.

    In \Cref{th:iso-worst}, we argued that any two equal circles larger than the twincircles can not be packed.

    We use Heron's formula again to calculate a density bound of

    $$\frac{2I(a/2, b, h)}{a/2\cdot h} = \frac{(a-2b+\sqrt{4b^2-a^2})^2\pi}{2a\sqrt{4b^2-a^2}}.$$
\end{proof}

%\begin{theorem}
%    Each $A \in \C(a)$ can be packed into an isosceles triangle with a largest angle $\gamma$ between $\frac{\pi}{2}$ and $\frac{\pi}{3}$ and an area of $a\frac{1+\frac{1}{\sin(\gamma)}}{\pi}$.
%\end{theorem}
%
%\begin{theorem}
%    For any $0 < x$ and $0 < y$, there are always 
%    a $(x+z)$-hat and a
%    Each $A \in \C(a)$ can be packed into an obtuse triangle with an incircle of area $a$.
%\end{theorem}
%
%\section{Squares}
%
%\begin{figure}
%    \begin{tikzpicture}[scale=2]
%        \hatsinsquare{0.5}
%    \end{tikzpicture}
%    \begin{tikzpicture}[scale=2]
%        \hatsinsquare{0.49}
%    \end{tikzpicture}
%    \begin{tikzpicture}[scale=2]
%        \hatsinsquare{0.4}
%    \end{tikzpicture}
%    \begin{tikzpicture}[scale=2]
%        \hatsinsquare{0.2}
%    \end{tikzpicture}
%    \begin{tikzpicture}[scale=2]
%        \hatsinsquare{0}
%    \end{tikzpicture}
%
%    \caption{Hat-in-square packings for different values of $\frac{x}{x+y}$}
%    \label{fig:hatsinsquare}
%\end{figure}
%
%
%
%Finally, we can bring the \textsc{Split} algorithm and the properties of the hat shapes together and give constructive proofs for the existence of circle packings:

%\begin{proof}
%Call the hat's smaller angles $\alpha$ and $\beta$. Set $f = $
%\end{proof}
%
%We are now ready to prove our main theorem:
%

\section{The problem with acute triangles}\label{sec:acute-triangles}

A class of triangles for which we could not show worst-case optimality are general acute triangles. The problem is that the condition for \Cref{th:overlap} is not met, which means that the two hats can overlap:

\fig{overlap}{For general acute triangles, the two hats might overlap.}

We worked on the following assumption:

\begin{conjecture}
    A circle instance can be packed in a triangle if the circles' combined area does not exceed the triangles incircle or twincircle, whichever is smaller.
\end{conjecture}

If this conjecture is true, surely there are strategies which can pack into acute triangles worst-case optimally. For example, we attempted to split the circle instance into four subinstances using a slightly modified \textsc{Split} algorithm, and then to pack four hats into the container, like in \Cref{fig:four}. Again, this is motivated by the observation that, when splitting each circle top-down into four equal circles, this strategy always works because the triangle is recursively divided into four similar triangles.

\fig{four}{Packing four hats into an acute triangle.}

Unfortunately, this strategy fails for some instances, like depicted in \Cref{fig:four-fail}. For this instance, the largest group, consisting of a single circle, cannot be packed if \emph{any} of the smaller groups is packed in the top or the left corner, because the remaining free space is not wide enough for the circle.

\fig{four-fail}{This strategy does not work for a container with a right-angle of $\pi/10$, incircle $1$ and the circle instance $\{0.55,0.15,0.15,0.15\}$.}

\section{Rectangles}\label{sec:rectangles}

Split Packing can also be used to pack circles worst-case optimally into rectangles. The basic idea is to divide the rectangle along a diagonal, and pack the subinstances produced by \textsc{Split} into these two halves. If one group gets larger than half, it gets rounded enough so that it sill works. The basic idea is to divide the rectangle along a diagonal, and pack the subinstances produced by \textsc{Split} into these two halves. If one group gets larger than half, it gets rounded enough so that it sill works.

\begin{figure}
    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0.5}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0.4}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0.3}
    \end{tikzpicture}

    \vspace{5mm}

    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0.2}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0.1}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \hatsinrect{0}
    \end{tikzpicture}

    \caption{Hat-in-rectangle packings for different values of $a_1$ and $a_2$.}
    \label{fig:hats-in-rect}
\end{figure}

At this point, we do not know how to handle \emph{all} rectangles, and this has to do with the different classes of worst-cases which appear when packing circles into rectangles of different ratios. \Cref{fig:long-rects} shows several examples. At the top, we show the conjectured worst-case instance. For squares, we already discussed the worst case---it consists of the square's twincircles, the two largest circles which can be packed into the square.

For rectangles with a slightly larger aspect ratio (like 1:1.3), we conjecture that the worst-case instance still consists of the rectangle's twincircles, but we do not know how to pack this area using Split Packing, because when cutting the rectangle along the circles' tangent, the resulting pieces are not triangular. At this point, we do not know how to deal with these kind of quadrilaterals recursively.

As the aspect ratio gets even larger, at some point the twincircle area gets larger than the incircle of the rectangle, whose diameter is as long as the rectangle's smaller side. It is obvious that any circle larger than this incircle can not be packed, so from this point forward, the worst-case instance of these “long” rectangles will be their incircles.

\fig[2.4]{long-rects}{Rectangles of different aspect ratios. Top: Their worst-case instances. Bottom: The incircles of their halves.}

At the bottom of \Cref{fig:long-rects}, we divided all rectangles along their diagonal, and inscribed circles into the resulting halves. We will show that we can pack circles worst-case optimally into a rectangle if the area of those two circles is at least as large as the worst-case area:
We know from the previous sections that we can pack right hats with incircle density. It is left to show that, if one of the two hats should get larger than the other one, they both can still be packed.

What is the aspect ratio of the rectangle's sides where the combined area of the two circles incribed in the halves is exactly equal to the incircle area? In \Cref{fig:rect-construction}, we see that the area of the incircle is $A = \pi(\frac{h}{2})^2$.

\fig[4]{rect-construction}{Constructing the case where $A = 2B$.}

The proof of \Cref{th:tri} on \cpageref{th:tri} discusses how to use Heron's formula to algebraically find the area of a triangle, given it's side lenghts.
In our case, $A = 2B$ is equivalent to

$$\frac{\pi}{4}h^2 = 2I(h,w,\sqrt{h^2+w^2}) = \frac{\pi aw(h+w-\sqrt{h^2+w^2}}{h+w+\sqrt{h^2+w^2}}$$

and this equation this is true for $w = \frac{2+3\s}{4}h \approx 1.5607h$.
This means that all rectangles whose side ratio is at least this large can be packed wost-case optimally, simply by using the split key $F = (1,1)$ and by placing two right hats in the rectangle.

\begin{theorem}
    Given a rectangle whose longer side $w$ is at least $\frac{2+3\s}{4} \approx 1.5607$ times as long as its shorter side $h$, let $a$ be the area of its incircle.
    All circle instances with a combined area of up to $a$ can be packed into the rectangle, and this area bound is tight. Expressed algebraically, the density bound is

    $$\frac{\pi h}{4w}.$$

\end{theorem}

\begin{proof}
    By \Cref{th:hats-in-rect} and the Split Packing Theorem, the rectangle is a $\C(a)$-shape.

    The $a$-circle's diameter is equal to the rectangle's smaller side, so it is obvious that any larger circles can not be packed.

    The density bound is the ratio of the circle's and the rectangle's area, which can be calculated to be $\frac{\pi (h/2)^2}{wh} = \frac{\pi h}{4w}$.
\end{proof}

%also works for rectangles whose twincircle area does not exceed their incircle area.

\chapter{Packing rubies}\label{ch:rubies}

In the last chapter, we showed how Split Packing can be used to pack circular objects into triangles.
As we explored generalizations of Split Packing during the creation of this thesis, we usually tried to find additional container shapes for which we could use Split Packing to pack circles with worst-case density. 
%As it turns out, Split Packing is even more powerful!

But at one point, we decided to try whether we could vary the “other half” of packing problems: The objects. We rarely had thought of packing objects other than circles.\footnote{After all, the preliminary title of this thesis was \emph{Circle Packing Algorithms}!} 
We were surprised to find out that, when we allowed to rotate objects, we could also use Split Packing to pack squares into a square container with worst-case density! Shortly after, we discovered that we could also use it to pack octagons with worst-case density. Both modified packing problems could be solved with only a very small modification of the algorithm.

As we know now, the reason why we can pack circles, squares, as well as octagons, is that all these shapes are subsets of the very special shape shown in \Cref{fig:ruby-intro}. We call this shape \emph{ruby}, because it looks like a cut gemstone from the side:

\fig{ruby-intro}{The “ruby” shape and its contained circle, square and hexagon.}

In this chapter, we will show how to pack rubies into squares and isosceles right triangles with worst-case density. As corollaries, we get worst-case optimal packing algorithms for circles, squares, and octagons for these containers for free!
In fact it turns out that, if you are given a set of objects, no matter what their shape is, if you can enclose them in rubies so that the total area of the rubies does not exceed the worst-case optimal case, then you can pack the shapes into these containers.

%If the container is a isosceles right triangle, one can generalize the split packing method a bit to be able to pack different objects than circles. Specifically, we can adapt the method so that it also packs regular octagons worst-case optimally, and so that it packs squares worst-case optimally when it is allowed to rotate them while packing.

\section{Gems and rubies}

For this generalization, we need another new shape, which has a similar function as last chapter's \emph{hats}. Our ruby shape has a very distinct way its corners are cut off. We generalize this cutoff to get to a family of shapes which call \emph{gems}:

\begin{definition}
    For each $0 \le a$ and $0 \le b$, an \emph{$(a,b)$-gem} is an isosceles right triangle with an incircle of area $a$, whose acute corners are cut off like shown in \Cref{fig:gem}: Each cut forms an angle of $\frac3 4\pi$ with the triangle's boundary, and the distance of each cut to the triangle's original corner is

    $$c(b) := \frac{(2+\s)(2\sqrt{\s-1}-1)}{\sqrt{2(\s-1)\pi}}\sqrt{b} \approx 0.6078 \sqrt{b}.$$

\end{definition}

\fig[4]{gem}{An $(a,b)$-gem.}

\begin{definition}
    A gem's associated split key is $(1,1)$, as usual for symmetric shapes.
\end{definition}

For the following proofs, we need to know a gem's dimensions in detail.
Consider an ($a,b$)-gem and let $r = \sqrt{\frac{a}{\pi}}$ be the radius of its incircle. By construction in \Cref{fig:gem-construction}, the hat has
\begin{itemize}
    \item cut-width $c(b) = \frac{(2+\s)(2\sqrt{\s-1}-1)}{\sqrt{2(\s-1)\pi}}\sqrt{b}$ (by definition),
    \item diagonal $D(a) = \s(\textcolor{blue}{r\s+r}) = (2+\s)\sqrt{\frac{a}{\pi}}$,
    \item width $w(a,b) = 2(\textcolor{blue}{r\s+r}) - 2c(b) = (2+2\s)\sqrt{\frac{a}{\pi}} - 2c(b)$, and
    \item corner-width $W(a,b) = (2+2\s)\sqrt{\frac{a}{\pi}} - c(b)$.
\end{itemize}

\fig[4]{gem-construction}{Dimensions of an $(a,b)$-gem.}

%We also introduce a nickname for the special case where $a=b$:
The definition of a gem is designed so that we get our ruby shape exactly for $a = b$:

\begin{definition}
    We call an $(a,a)$-gem an \emph{$a$-ruby}.
\end{definition}

An $a$-ruby contains the following shapes, see \Cref{fig:gem}:

\begin{itemize}
    \item A circle of area $a$,
    \item a square of area $\frac{3+2\s}{2\pi}a \approx 0.9276a$, and
    \item a regular octagon of area $\frac{8\s-8}{\pi}a \approx 1.0548a$.
\end{itemize}

This is because if the circle's radius is $r = \sqrt{a/\pi}$, then the square has an edge length of $((1+1/\s)r$, so its area is $(1+\s+1/2)r^2$. Regular $n$-gons with an apothem\footnote{The apothem is the distance of the polygon's center to its sides.} of $r$ have an area of $nr^2\tan(\pi/n)$, which, for $n=8$, amounts to $8r^2(\s-1)$.

\fig{ruby}{An $a$-ruby and its contained circle, square and hexagon.}

A ruby itself has an area of $\frac{8\sqrt{2(7+5\s)}-3(7+4\s)}{\pi}a \approx 1.4225a$. TODO derive

We will also use gems and rubies where only one corner is cut off, we will call them \emph{sharp}:

\begin{definition}
    A \emph{sharp $(a,b)$-gem} is a isosceles triangle where only one corner is cut off like in the definition of a gem, see \Cref{fig:sharp-ruby}. A \emph{sharp ruby} is a sharp $(a,a)$-gem. A \emph{sharp ruby instance} is a circle instance where the real numbers define the areas of the sharp rubies' incircles.
\end{definition}

\fig{sharp-ruby}{A \emph{sharp} ruby.}

A sharp ruby is a superset of a regular ruby with the same parameters and has an area of $\frac{4\sqrt{2(7+5\s)}-5\s-9}{\pi}a \approx 1.6388a$. TODO derive

From this point forward, we will no longer pack circles, but (regular and sharp) rubies. To simplify talking about these instances, we make the following definition:

\begin{definition}
    A \emph{ruby instance} is defined excactly like a circle instance (see \Cref{def:circle-instance}), except that the real numbers now define the areas of the rubies' incircles. $\R$ is the set of all ruby instances, $\R(a,b)$ is defined analogously.
    Similarly, we call the set of all \emph{sharp ruby instances} $\myS$.
\end{definition}

One way to think about ruby instances is that they consist of the rubies “built around” the circles of a circle instance.

\begin{lemma}\label{th:gems-in-gem}
    Any two $(a, 0, (1,1))$-conjugated sharp gems can be packed into a $(a,0)$-gem.
\end{lemma}

\begin{proof}
    Assume \wlofg\ that the two gems are a sharp $(a_1, b_1)$-gem and a sharp $(a_2, b_2)$-gem with $a_1 \ge a_2$, meaning that we always swap the larger gem to the left. Also, let us normalize $a$ to 1 to make calculations easier. The proofs hold for all $a$, one just needs to multiply all areas with $a$ and all lengths with $\sqrt{a}$.

    Again, we will show that we can always place the gems so that (1) they do not overlap each other and (2) they do not overlap the container. See \Cref{tab:gems-in-gem} for an overview of the different cases, along with some more informal reasoning.

    \begin{table}
        \caption{Gem-in-gem packings for different values of $a_1$ and $a_2$.}
        \label{tab:gems-in-gem}

        \begin{tabular}{cp{8cm}}
            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.5}{0}
            \end{tikzpicture}
            & The two gems are placed so that their tips touch the container's base and point towards each other. We assume $a_1 \ge \frac 1 2$ and normalize $a_1 + a_2$ to 1.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.334}{0}
            \end{tikzpicture}
            & They are then pushed as far to the left/right as possible. As $a_1$ grows, the gem becomes “rounded” enough so that it does not overlap the container.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.333}{0}
            \end{tikzpicture}
            & As soon as $a_1 > \frac 2 3$, we know from \Cref{th:split-properties} that $b_1 = a_1$, so the gem takes the form of a ruby from this point forward. We display it in a darker shade here.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.172}{0}
            \end{tikzpicture}
            & When $a_1 = 2\s-2$, the ruby touches the container's right leg.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.171}{0}
            \end{tikzpicture}
            & So when the ruby gets larger than that, it has to be rotated so that its tip points up. That these two positions exactly fit is the defining property of the ruby shape.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0.1}{0}
            \end{tikzpicture}
            & In this orientation, it can then grow without overlapping the container and the smaller gem.\\

            \begin{tikzpicture}[scale=2,baseline={([yshift={-\ht\strutbox}]current bounding box.north)},outer sep=0pt,inner sep=0pt]
                \gemsingem{0}{0}
            \end{tikzpicture}
            & When $a_1 = 1$, the ruby touches all sides of the container triangle.\\
        \end{tabular}
    \end{table}

    The smaller gem is always placed so that its tip touches the bottom of the container gem and its left corner fits into the containers right corner. By assumption, its incircle is smaller than $\frac{1}{2}$, so it will fit inside the right half of the container and thus never overlap the container's boundary. For the larger gem, there are three cases:

    \paragraph{Case 1}

    When $a_1 \le \frac{2}{3}$, “normal” rounding rules apply. We know from \Cref{th:split-properties} that $b_1 \ge 2a_1 - 1$. We have to show that the corner-width of our gem does not exceed the diagonal of the container:

    \begin{align*}
        W(a_1, 2a_1-1) &\le D(1)\\
        \iff (2+2\s)\sqrt{\frac{a_1}{\pi}} - \frac{(2+\s)(2\sqrt{\s-1}-1)}{\sqrt{2(\s-1)\pi}}\sqrt{2a_1-1} &\le \frac{2+\s}{\sqrt{\pi}}
    \end{align*}

    Expressions of the form $f\sqrt{x} - g\sqrt{2x-1}$ have their only extremum at $x = \frac{f^2}{2(f^2-2g^2)}$. This point turns out to be a global minimum for $f,g > 0$.
    In our case, this minimum point is at $a_1 = (1+5\s+4\sqrt{1+5\s})/35 \approx 0.5553$.
    As we can check our inequality to be true for $a_1 = 1/2$ as well as for $a_1 = \frac 2 3$, this means that it always holds between those two values.

    \paragraph{Case 2}

    In the range $\frac{2}{3} \le a_1 \le 2\s-2$, we know from \Cref{th:split-properties} that $b_1 = a_1$, essentially making the gem into a ruby. We have to show that the corner-width of the ruby is always smaller than the diagonal of the container:

    $$W(a_1, a_1) \le D(1)$$

    But in the range for $a_1$ specified above, this is true:

    $$W(a_1, a_1) = \frac{(1+\s)^{3/2}}{\sqrt{\pi}}\sqrt{a_1} \le \frac{(1+\s)^{3/2}}{\sqrt{\pi}}\sqrt{2\s-2} = \frac{2+\s}{\sqrt{\pi}} = D(1)$$

    In both Case 1 and Case 2, the two gems do not overlap each other because the projections of their incircles do not overlap. See \Cref{th:hats-in-iso} for a proof.

    \paragraph{Case 3}

    For $a_1 = 2\s-2$, the ruby touches the containers right leg.
    When $2\s-2 < a_1 \le 1$, it is no longer possible to place the gem like before without overlapping the container. In this case, we rotate it so that its bottom touches the bottom of the container gem and push it as far left as possible.

    This is actually the defining property for the shape of the ruby: The cut-off is exactly so large that, when the growing ruby touches the container, the remaining space left over by the smaller gem is a (symmetric) kite, so that the ruby can be rotated.

    In this orientation, it will never overlap the container: It can be enclosed in a (non-rounded) $(a_1, 0)$-gem, with the same rotation as the container gem, and $a_1 \le 1$, so our ruby always fits inside the container gem.

    To show that the ruby does not overlap the smaller gem, we have to show that the following inequality holds for $2\s-2 \le a_1 \le 1$: The corner-width of the ruby, added to the diagonal of the small gem, must not exceed the container's width:

    \begin{align*}
        W(a_1,a_1) + D(1-a_1) &\le w(1,0)\\
        \iff (2+2\s)\sqrt{\frac{a_1}{\pi}} - \frac{(2+\s)(2\sqrt{\s-1}-1)}{\sqrt{2(\s-1)\pi}}\sqrt{a_1} + \frac{2+\s}{\sqrt{\pi}}\sqrt{1-a_1} &\le \frac{2\s + 2}{\sqrt{\pi}}\\
        \iff \frac{(1+\s)^{3/2}}{\sqrt{\pi}}\sqrt{a_1} + \frac{2+\s}{\sqrt{\pi}}\sqrt{1-a_1} &\le \frac{2\s + 2}{\sqrt{\pi}}
    \end{align*}

    Expressions of the form $f\sqrt{x} + g\sqrt{1-x}$ have their only extremum at $x = \frac{f^2}{f^2+g^2}$. This point turns out to be a global maximum for $f,g > 0$. In our case, the maximum is at $\frac{1+2\s}{7} \approx 0.5469$, and we have equality for $a_1 = 2\s-2 \approx 0.8284$. If $a_1$ gets larger than that, the left hand side of the equation will only get smaller, so that the inequality holds. This concludes the proof of \Cref{th:gems-in-gem}.
\end{proof}

Like with hats, “rounding” the container gem to a sharp gem with larger cut-off does not affect the packing properties:

\begin{lemma}\label{th:rounded-gems-in-gem}
    Any two $(a, b, (1,1))$-conjugated sharp gems can be packed into a sharp $(a,b)$-gem.
\end{lemma}

\begin{proof}
    \Cref{th:gems-in-gem} tells us that this theorem is true for $b = 0$. 
    For $b > 0$, we flip the containers cut-off corner to the right, and also flip the smaller gem's cut-off corner so that it points to the right. Because the cut-off has the same shape, the inner gems will not overlap the container.
\end{proof}

\fig{gems-rounding}{Cutting one corner of each gem by the same value does not affect the packing.}

\begin{theorem}\label{th:sharp-gem}
    Any sharp ruby instance $R \in \C(a,b)$ can be packed into a sharp $(a,b)$-gem.
\end{theorem}

\begin{proof}
    By \Cref{th:hats-in-iso} and the Split Packing Theorem.
\end{proof}

\begin{theorem}\label{th:gem}
    Any ruby instance $R \in \C(a,b)$ can be packed into an $(a,b)$-gem.
\end{theorem}

\begin{proof}
    This follows analogously to the reasoning with sharp gems. In this case, when cutting off the corners of the container gem, all corners of the contained gems are cut off by the same value, so they still fit inside.
\end{proof}

\section{Isosceles right triangles}

As isosceles right triangles are simply non-rounded sharp gems, this is again going to be a short section.

\begin{theorem}\label{th:iso}
    Given an isosceles right triangle with an incircle of area $a$, all sharp ruby instances with a combined incircle area of up to $a$ can be packed into the triangle, and this area bound is tight.
\end{theorem}

\begin{proof}
    The triangle is a sharp $(a,0)$-gem, and by \Cref{th:gem} we can pack any sharp ruby instance $S \in \myS(a)$ into such a gem.

    A ruby with an incircle area of more than $a$ can not be packed, as its incircle would be larger than the triangle's incircle.
\end{proof}

As a minor corollary, as rubies are subsets of sharp rubies of the same incircle, we can state the same property for regular rubies.

\begin{corollary}
    Given an isosceles right triangle with an incircle of area $a$, all ruby instances with a combined incircle area of up to $a$ can be packed into the triangle, and this area bound is tight.
\end{corollary}

We can make an observation here: Given an isosceles right triangle with a incircle area of $a$, and some arbitrary objects, if one can enclose each object in a sharp ruby, and the combined incircle area of these rubies is not larger than $a$, then the objects can be packed into the triangle. This is a very general result which can be used to make statements about some interesting classes of shapes:

\begin{corollary}
    Given a right isosceles triangle with an incircle area of $a$, the following object instances can be packed into the square.

    \begin{itemize}
        \item All circle instances with a combined area of up to $a$,
        \item all octagon instances with a combined area of up to $\frac{8\s-8}{\pi}a \approx 1.0548a$, and
        \item all square instances with a combined area of up to $\frac{3+2\s}{2\pi}a \approx 0.9276a$, which is also exactly half of the square's area.
    \end{itemize}

    All of these area bounds are tight.
\end{corollary}

\begin{proof}
    As demonstrated above, the three shapes are subsets of rubies in these specific area ratios. To pack them, enclose all of them in the smallest possible sharp ruby. The combined incircle area of these rubies will now be at most $a$. We then know from \Cref{th:iso} that we can always pack these rubies.

    The tightness of these bounds is obvious for circles and hexagons. For squares, the tightness follows from the result by \textcite{gobel1979geometrical} that the largest two squares that can be packed into a square are quarter-squares. This implies that, when cutting the square along its diagonal, there is no larger square that can be packed into an isosceles right triangle than one with half the triangle's area.
\end{proof}

\section{Squares}

Finally, we turn to square containers. Having established $(a,b)$-gems as $\R(a,b)$-shapes, to argue about the packing properties of squares is going to be relatively straightforward.

\begin{lemma}\label{th:square-worst}
    Two touching equal circles, packed into opposing corners of a square, are the squares \emph{twincircles}, meaning that there are no two larger equal circles which can be packed.
\end{lemma}

\begin{proof}
    %The instance ${\frac{a'}{2}, \frac{a'}{2}}$ cannot be packed. TODO
    This can be proven similarly like in \Cref{th:iso-worst}: Let $r$ be the radius of these circles. When eroding the square by $r$, the result is a square with a diagonal of $2r$. When eroding by a larger radius $r + \varepsilon$, the diagonal will be smaller than $2r$. But the centers of the two circles need to be placed at least $2r + 2\varepsilon$ away from each other, and additionally need a distance of at least $r + \varepsilon$ from the square's boundary. We see that both constraints can not be satisfied at the same time.
\end{proof}

\begin{lemma}\label{th:square-twincircle-area}
    The twincircles of a square with area $a$
    have a combined area of
    $$\frac{\pi}{3+2\s}a \approx 0.5390a.$$
\end{lemma}

\begin{proof}
    We can construct the twincircles' radius $r$ as seen in \Cref{fig:square-worst-construction}:

    \begin{equation*}
        2r + 2\frac{r}{\s} = \sqrt{a} \iff r = \frac{\sqrt{a}}{2 + \s}
    \end{equation*}

    So, the combined area of the twincircles is

    $$2\pi r^2 = 2\pi\frac{a}{4 + 4\s + 2} = \frac{\pi}{3+2\s}a$$
\end{proof}

\fig{square-worst-construction}{Constructing the twincircles' radius $r$.}

Note that in the next lemma, we no longer pack \emph{sharp} gems, but regular gems, whose two corners are cut off. The reason it will become clear in \Cref{fig:gems-in-square}: A large sharp $(a,0)$-ruby cannot be packed into the square.

\begin{lemma}\label{th:gems-in-square}
    Consider a square with twincircle area $a$.
    For all $(a,0,(1,1))$-rounded tuples $(a_1, b_1)$ and $(a_2, b_2)$, the following two shapes can be packed into the hat:
    \begin{itemize}
        \item An isosceles right $(a_1,b_1)$-gem and
        \item an isosceles right $(a_2,b_2)$-gem.
    \end{itemize}
\end{lemma}

\begin{figure}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.5}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.48}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.45}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.4}
    \end{tikzpicture}

    \vspace{5mm}

    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.3}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.2}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0.1}
    \end{tikzpicture}
    \begin{tikzpicture}[scale=2.5]
        \gemsinsquare{0}
    \end{tikzpicture}

    \caption{Hat-in-square packings for different values of $a_1$ and $a_2$}
    \label{fig:gems-in-square}
\end{figure}

\begin{proof}
    Place the tips of the gems in two opposing corners of the square, like in \Cref{fig:gems-in-square}.
    This placement constitues a valid packing because (1) the gems fit into the square individually and (2) the gems never overlap. This can be proven algebraically in exactly the same fashion as in \Cref{th:gems-in-gem}, where we proved a similar statement about packing into gems.

    %We can use the previously established \Cref{th:gems-in-gem} for this proof, by only considering the situation above the square's lower-left to upper-right diagonal. If an isosceles right $(\frac{a_1}{2},b_1)$-hat and an isosceless right $(\frac{a_2}{2},b_2)$-hat can be packed into an isosceles right $(\frac{a}{2})$-hat, then this proof is complete.

    %TODO fig

    %As the container hat is symmetric, assume $a_1 \ge a_2$.

    %$(a_1, b_1)$ and $(a_2, b_2)$ are $(a,0,(1,1))$-conjugated. By \Cref{def:rounded}, this means that $b_1 \ge a_1-a_2$. But then also $b_1 \ge \frac{a_1}{2} - \frac{a_2}{2}$.

    %If $\frac{a_1}{2} \ge 2 \frac{a_2}{2},$

    %which means that $(\frac{a_1}{2},b_1)$ and $(\frac{a_2}{2},b_2)$ are also $(a,0,(1,1))$-rounded, fulfilling the proposition of \Cref{th:hats-in-hat}.
\end{proof}

%
%    \begin{itemize}
%        \item[(1)]
%            The hats fit into the square individually if their diagonal never gets larger than the square's edge length $\sqrt{\Psi(x+y)} = \frac{1+\s}{\sqrt{\pi}}\sqrt{x+y}$.
%            As $x \le \frac {x+y} 2$, \Cref{lm:sizes} directly tells us that the $x$-hat has a diagonal of at most
%            \begin{align*}
%                d(x,0) \le d(\frac{x+y}{2},0) = \sqrt{\frac{\frac{x+y}{2}}{\pi}}(2+\s) + 0 = \sqrt{\Psi(x+y)}
%            \end{align*}
%
%            As for the $(y,y-x)$-hat, its diagonal is also never larger than $\sqrt{\Psi(x+y)}$: \todo[inline]{algebraic proof TBD :-)}
%
%            \begin{tikzpicture}
%                \begin{axis}[height=5cm,xtick={0,0.5},xlabel=$\frac{x}{x+y}$,domain=0:0.5,legend pos=outer north east,no markers,samples=500]
%                    \addplot[red,thick] {sqrt((1-x)/pi)*(2+sqrt(2))-sqrt((1-2*x)/pi)*sqrt(2)};
%                    \addplot[blue,thick] {(1+sqrt(2))/sqrt(pi)};
%                    \legend{$\frac{d{(y,y-x)}}{\sqrt{x+y}}$,$\sqrt{\Psi}$}
%                \end{axis} 
%            \end{tikzpicture}
%
%            %\begin{align*}
%            %    d(y,y-x)
%            %    &= \sqrt{\frac{y}{\pi}}(2+\s)-\sqrt{\frac{y-x}{\pi}}\s\\
%            %    &\le \sqrt{\frac{\frac{x+y}{2}}{\pi}}(2+\s)-\sqrt{\frac{y-y}{\pi}}\s\\
%            %    &= \frac{1+\s}{\sqrt{\pi}}\sqrt{x+y} = \sqrt{\Psi(x+y)}
%            %\end{align*}
%
%        \item[(2)]
%            The square has a diagonal of $\sqrt{2a}$.
%            The hats do not overlap if their combined heights never exceeds this diagonal. The height of a right isosceles $a$-hat is $\sqrt{\frac{a}{\pi}}(1+\s)$, and the following inequalities hold:
%
%            \begin{align*}
%                &= \sqrt{\frac{a_1}{\pi}}(1+\s) + \sqrt{\frac{a_2}{\pi}}(1+\s)\\
%                &= \frac{1+\s}{\sqrt\pi}(\sqrt{a_1}+\sqrt{a_2})\\
%                &\le \frac{1+\s}{\sqrt\pi}(\sqrt{2a_1+2a_2})\\
%                &= \s\frac{1+\s}{\sqrt\pi}\sqrt{a_1+a_2}\\
%                &\le \s\frac{1+\s}{\sqrt\pi}\sqrt{\frac{\pi}{3+2\s}a}\\
%                &= \s(1+\s)\sqrt{\frac{1}{(1+\s)^2}a} = \sqrt{2a} \qedhere
%            \end{align*}
%    \end{itemize}
%\end{proof}

%\begin{proof}
%    If $A$ only consists of a single $a$-circle, it can be placed at the center of the square, as its diameter of $2\sqrt{\frac{a}{\pi}} \approx 1.1284\sqrt{a}$ is smaller than the squares edge length $\sqrt{\Psi a} \approx 1.3621\sqrt{a}$. Otherwise, by \Cref{th:split-property}, \textsc{Split} decomposes $A$ into $X \in \C(x)$ and $Y \in \C(y,y-x)$. By \Cref{th:circlesinhat}, we can pack $X$ into a $x$-hat and $Y$ into a $(y,y-x)$-hat. By \Cref{th:hats-in-square}, we can pack those two hats into the square.
%
%    See \Cref{fig:example} for a complete example packing.
%\end{proof}
%
%\begin{figure}
%    \includegraphics[width=0.5\textwidth]{square_example.png}
%    \caption{Packing of an example instance.}
%    \label{fig:example}
%\end{figure}

\begin{theorem}\label{th:square}
    Given a square with a twincircle area of $a$, all ruby instances with a combined incircle area of up to $a$ can be packed into the square, and this area bound is tight. Expressed algebraically, the density bound for the rubies' incircles is

    $$\frac{\pi}{3+2\s}.$$
\end{theorem}

\begin{proof}
    By \Cref{th:gems-in-square} and the Split Packing Theorem, the square is a $\R(a)$-shape.

    Two rubies with a combined incircle area of more than $a$ will have incircles which are larger than the square's twincircles. As shown in \Cref{th:square-worst}, those can not be packed, which means that the rubies can not be packed, as well.

    The density bound was proven in \Cref{th:square-twincircle-area}.
\end{proof}

We can make an observation here: Given a square with a twincircle area of $a$, and some arbitrary objects, if one can enclose each object in a ruby, and the combined incircle area of these rubies is not larger than $a$, then the objects can be packed into the square. This is a very general result which can be used to make statements about some interesting classes of shapes:

\begin{corollary}
    Given a square with a twincircle area of $a$, the following object instances can be packed into the square.

    \begin{itemize}
        \item All circle instances with a combined area of up to $a$,
        \item all octagon instances with a combined area of up to $\frac{8\s-8}{\pi}a \approx 1.0548a$, and
        \item all square instances with a combined area of up to $\frac{3+2\s}{2\pi}a \approx 0.9276a$, which is also exactly half of the square's area.
    \end{itemize}

    All of these area bounds are tight.
\end{corollary}

\begin{proof}
    As demonstrated above, the three shapes are subsets of rubies in these specific area ratios. To pack them, enclose all of them in the smallest possible ruby. The combined incircle area of these rubies will now be at most $a$. We then know from \Cref{th:square} that we can always pack these rubies.

    The tightness of these bounds for circles was shown in \Cref{th:square-twincircle-area}. For the same reason, two octagons with larger incircles can not be packed: Their incircles would overlap, which means that the octagons themselves would overlap. For squares, that the largest two squares that can be packed into a square are two quarter-squares was shown by \textcite{gobel1979geometrical}.
\end{proof}

Note that the result that you can pack all sets of squares with a density of up to 1 is already known, even without rotations, as it can be done with Moon and Moser's Shelf Packing \cite{MM1967some}. For circles and octagons, this is a new result, as far as we know.

%\begin{theorem}
%    The Splitpack algorithm, when used to pack circles into squares, is a $\frac{3+2\s}{\pi} \approx 1.8552$-approximation algorithm, and this factor is tight.
%\end{theorem}
%
%\begin{proof}
%    When packing a circle instance $C \in \C(a)$ into a square, the smallest possible square container also has area $a$. Indeed, one can construct an instance $C$ which can be packed into a square of area $a+\varepsilon$ by constructing an Apollonian gasket or another asymptotically space-filling circle configuration.
%
%    On the other hand, by \Cref{th:square}, Splitpack packs $C$ into a square of area $\frac{3+2\s}{\pi}a \approx 1.8552a$.
%\end{proof}
%
%\begin{theorem}
%    For packing equal circles, Splitpack gives a xxx-approximation.
%\end{theorem}

\chapter{Conclusion}\label{ch:conclusions}

Re-state results

Significance

Strengths and limitations

Potential applications

\section{Future work}

In this thesis, we mainly considered triangular and square containers. It would be interesting to see whether the Split Packing technique could be adapted to even \textbf{more container types}, like circles, ovals, regular polygons, or generalized quadrilaterals. For some of these container types, even the worst-case instance does not seem obvious. For circular and “almost square” rectangular containers, we assume the worst cases would again be their twincircles, see \Cref{fig:circle-rect-worst}, but it is unclear how to deal with the resulting shapes when cutting along the circles' tangent: Compared to triangular and square containers, these shapes cannot be split into self-similar pieces. It is also possible that the depicted instances are not the actual worst cases.

\fig[1.5]{circle-rect-worst}{Assumed worst-case instances for a circle and a near-square rectangle.}

Also, the problem of packing worst-case optimally into \textbf{acute triangles} is still open. See \Cref{sec:acute-triangles} for a discussion on why the Split Packing approach which we used for non-acute triangles does not directly work for acute ones. If one could find a strategy for packing worst-case optimally into acute triangles, then, combined with the results of this thesis, we would have an elegant, general result for all triangles.

Instead of packing circular, square, and octagonal objects, \textbf{more object types} could be considered, like ovals, rectangles, or even more general convex objects. For these modified problems, again, it seems non-obvious what the worst-case packings would look like.

For long rectangles (and long containers in general), in \Cref{sec:rectangles} we discussed that the maximally packable area is limited by the relatively small height, making the problem rather trivial. It would be a more interesting problem if we require a \textbf{maximum object size}: What is the larest $a$ so that all circle instances with a combined area of at most $a$, each of which have a diameter \emph{not larger than a rectangle's smaller side}, can be packed into that rectangle?

The Split Packing method as described in this thesis is a strictly offline approach, as the greedy splitting requires sorting the complete input instance, and then proceeds in a top-down fashion. It would be interesting to study to which extent the obtained results could be replicated in an \textbf{online situation}. The best algorithm that packs squares into a square in an online fashion is currently by \textcite{brubach2014improved} and gives a density guarantee of $\frac{2}{5}$. As mentioned in \Cref{sec:related-squares}, we can directly use this algorithm to pack circles into a square in an online situation with a density of $\frac{\pi}{10} \approx 0.3142$. It would be particularly interesting to see whether some form of online Split Packing would give better results.

Our original motivation stemmed from origami design. When only packing circles, the resulting origami structures resemble arbitrary stars. When one wants to design general tree-shaped structures, it is neccessary to introduce seperating pathways between the circles, a technique pioneered by \textcite{lang1996computational}. See \Cref{fig:origami} for an example of such a \textbf{circle/river packing}. We have not been able to obtain a constant-factor approximation algorithm for this extended problem, but it would be highly interesting whether Split Packing could still lead to any progress in that area.

\begin{figure}
    \includegraphics[width=\textwidth]{origami.png}
    \caption{A crease pattern for folding the tree on the left can be realized by packing the circles and rivers on the right in a square.}\label{fig:origami}
\end{figure}

It seems like a natural extension to apply Split Packing to \textbf{three-dimensional packing} problems. For example, one could try to pack spheres into a cube using a Split Packing approach. Unfortunately, this does not directly seem to work out: Assuming the worst case are two equally sized spheres packed into opposite corners of the cube, one would like to be able to cut the cube along the spheres' tangential plane. This results in two shapes like depicted on the right in \Cref{fig:cube-half}, but it is not possible to fit two quarter-spheres into each of these polyhedra. Still, any extensions regarding three dimensional problems would be notable.

\begin{figure}
    \includegraphics[width=0.45\textwidth]{cube.png}
    \includegraphics[width=0.45\textwidth]{cube-half.png}
    \caption{Left: Assumed worst case for packing spheres into a cube. Right: Two quarter-spheres do not fit in a half.}\label{fig:cube-half}
\end{figure}

Instead of packing circles into containers, one could ask a question which is in some sense the opposite problem: What is the smallest area so that we can always \textbf{cover the container} with circles of that combined area? For example, if we want to cover a isosceles right triangle, and restrict ourselves to at most two circles in our input instance, the area of a circle whose diameter equals the triangle's hypothenuse is sufficient, see \Cref{fig:cover}. It would now be neccessary to show that the area of the left circle is always enough to cover the quadrilateral on the left, and we did not find an argument fot that, yet.

\fig[1.5]{cover}{A isoscles right triangle can always be covered by two circles with a combined area of its excircle.}

\printbibliography

\end{document}
